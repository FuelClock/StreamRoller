<!--
      StreamRoller_source Copyright 2023 "SilenusTA https://www.twitch.tv/olddepressedgamer"
 
      StreamRoller is an all in one streaming solution designed to give a single
      'second monitor' control page and allow easy integration for configuring
      content (ie. tweets linked to chat, overlays triggered by messages, hue lights
      controlled by donations etc)
 
      This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU Affero General Public License as published
      by the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
 
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU Affero General Public License for more details.
 
      You should have received a copy of the GNU Affero General Public License
      along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-->
<script src="/streamroller-message-api.cjs"></script>
<script>

    //"use strict"
    const default_serverConfig = {
        __version__: "0.1",
        extensionname: "overlaysources",
        channel: "OVERLAYSOURCES_CHANNEL",
        overlaysourcesenabled: "off",
        logginglevel: "0",
        overlaysources_restore_defaults: "off"
    };
    let serverConfig = structuredClone(default_serverConfig);
    let serverData = {}
    const localConfig =
    {
        heartBeatTimeout: "6000",
        connected: true,
        DataCenterSocket: null,
        smallsettingscode: "",
        largesettingscode: "",
        overlayfiles: [], // list of overlay names
        overlays: [] // holds the overlay classes

    }

    // store the values passed in by express
    var host = '<%= host %>';
    var port = '<%= port %>';
    localConfig.overlayfiles = '<%= overlayfilenames %>'.split(',');
    localConfig.heartBeatTimeout = parseInt('<%= heartbeat %>') + 1000;

    window.addEventListener('load',
        async function ()
        {
            await LoadOverlays()
            ConnectToDataCenter(host, port);
        });
    const default_triggersandactions =
    {
        extensionname: serverConfig.extensionname,
        description: "Provides web page overlays to use with OBS Browser Sources. To use load the browser source http://localhost:3000/overlaysources",
        triggers: [],
        actions: [],
    }

    let triggersandactions = structuredClone(default_triggersandactions);
    // ============================================================================
    //                           FUNCTION: ConnectToDataCenter
    // ============================================================================
    function ConnectToDataCenter (host, port)
    {
        try
        {
            localConfig.DataCenterSocket = sr_api.setupConnection(onDataCenterMessage, onDataCenterConnect, onDataCenterDisconnect,
                host, port);
        } catch (err)
        {
            console.log("datahandler.initialise", "DataCenterSocket connection failed:", err);
        }
    }
    // ============================================================================
    //                           FUNCTION: onDataCenterDisconnect
    // ============================================================================
    function onDataCenterDisconnect (reason)
    {
        localConfig.connected = false;
    }
    // ============================================================================
    //                           FUNCTION: onDataCenterConnect
    // ============================================================================
    function onDataCenterConnect (socket)
    {
        // Create/Join the channels we need for this
        sr_api.sendMessage(localConfig.DataCenterSocket,
            sr_api.ServerPacket("CreateChannel",
                serverConfig.extensionname,
                serverConfig.channel));

        sr_api.sendMessage(localConfig.DataCenterSocket,
            sr_api.ServerPacket(
                "RequestConfig",
                serverConfig.extensionname
            ));

        //request software version
        sr_api.sendMessage(localConfig.DataCenterSocket,
            sr_api.ServerPacket(
                "RequestSoftwareVersion",
                serverConfig.extensionname,
                serverConfig.channel
            ));
        heartBeatCallback();
        localConfig.connected = true;
    }
    // ============================================================================
    //                           FUNCTION: onDataCenterMessage
    // ============================================================================
    function onDataCenterMessage (server_packet)
    {
        // -------------------------------------------------------------------------------------------------
        //                  RECEIVED CONFIG
        // -------------------------------------------------------------------------------------------------
        if (server_packet.type === "ConfigFile")
        {

            // check it is our config
            if (server_packet.to === serverConfig.extensionname)
            {
                if (server_packet.data.__version__ != default_serverConfig.__version__)
                {
                    serverConfig = structuredClone(default_serverConfig);
                    console.log("\x1b[31m" + serverConfig.extensionname + " ConfigFile Updated", "The config file has been Updated to the latest version v" + default_serverConfig.__version__ + ". Your settings may have changed" + "\x1b[0m");
                }
                else
                {
                    // update our config
                    if (server_packet.data != "")
                    {
                        serverConfig = structuredClone(server_packet.data)
                    }
                }
                // if we have new stuff in our config (software update) but the user doesn't we need to save it                
                SendSettingsWidgetSmall("");
                SendSettingsWidgetLarge("");
                SaveConfigToServer();
            }
        }
        // -------------------------------------------------------------------------------------------------
        //                  RECEIVED SOFTWARE VERSION
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "SoftwareVersion")
        {
            localConfig.SoftwareVersion = server_packet.data;
        }
        else if (server_packet.type === "ExtensionMessage")
        {
            let extension_packet = server_packet.data;
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED SETTINGS WIDGET SMALL REQUEST
            // -------------------------------------------------------------------------------------------------
            if (extension_packet.type === "RequestSettingsWidgetSmallCode")
            {
                SendSettingsWidgetSmall(extension_packet.from);
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED SETTINGS WIDGET SMALL REQUEST
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "RequestSettingsWidgetLargeCode")
            {
                SendSettingsWidgetLarge(extension_packet.from);
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED MODAL DATA (someone hit submit on our dialog)
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "SettingsWidgetSmallData")
            {
                // check that it is not from us as we process our own code internally
                if (extension_packet.from != serverConfig.extensionname)
                {
                    for (const [key, value] of Object.entries(serverConfig))
                    {
                        if (value === "on" && !extension_packet.data[key])
                            serverConfig[key] = "off";
                        else if (key in extension_packet.data)
                            serverConfig[key] = extension_packet.data[key];
                    }
                    SaveConfigToServer();
                    // update anyone that may have out modal
                    SendSettingsWidgetSmall("");
                    SendSettingsWidgetLarge("");
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED MODAL DATA (someone hit submit on our dialog)
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "SettingsWidgetLargeData")
            {
                // check that it is not from us as we process our own code internally
                if (extension_packet.from != serverConfig.extensionname)
                {
                    // turn off all checkbox values in config so they will get set if they are returned
                    // nb, if checkbox is de-selected it will not be in the extension_packet.data object
                    for (const [key, value] of Object.entries(serverConfig))
                    {
                        if (value === "on")
                            serverConfig[key] = "off";
                    }
                    for (const [key, value] of Object.entries(extension_packet.data))
                    {
                        //lets check our settings and send out updates as required
                        if (value === "on")
                            serverConfig[key] = "on";
                        else
                            serverConfig[key] = value;
                    }
                    SaveConfigToServer();
                    // update anyone that may have out modal
                    SendSettingsWidgetLarge("");
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                   Send Trigger and Actions
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "SendTriggerAndActions")
            {
                if (extension_packet.to === serverConfig.extensionname)
                {
                    sendTriggersAndActions(server_packet.from);
                }
            }// -------------------------------------------------------------------------------------------------
            //                   RECEIVED Unhandled extension message
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type.indexOf("action_") == 0)
            {
                processAction(extension_packet)
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED Unhandled extension message
            // -------------------------------------------------------------------------------------------------
            else
            {
                console.log(".onDataCenterMessage", "ExtensionMessage not handled ", extension_packet.type, " from ", extension_packet.from);
            }
        }
        // -------------------------------------------------------------------------------------------------
        //                       RECEIVED CHANNEL DATA
        //                  from a channel we are monitoring
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "ChannelData")
        {
            let extension_packet = server_packet.data;
            // example of a channel message
            if (server_packet.dest_channel === "CHATMOOD_CHANNEL")
                console.log(extension_packet.data)

            // -------------------------------------------------------------------------------------------------
            //                           UNHANDLED CHANNEL DATA
            // -------------------------------------------------------------------------------------------------
            else
            {
                console.log(".onDataCenterMessage", "Channel Data ", server_packet, " not handled");
            }
        }
        // -------------------------------------------------------------------------------------------------
        //                           UNKNOWN CHANNEL MESSAGE RECEIVED
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "UnknownChannel")
        {
            //channel might not exist yet, extension might still be starting up so lets rescehuled the join attempt
            // need to add some sort of flood control here so we are only attempting to join one at a time
            if (server_packet.data != "")
            {
                console.log(".onDataCenterMessage", "Channel " + server_packet.channel + " doesn't exist, scheduling rejoin");
                setTimeout(() =>
                {
                    sr_api.sendMessage(localConfig.DataCenterSocket,
                        sr_api.ServerPacket(
                            "JoinChannel",
                            serverConfig.extensionname,
                            server_packet.data
                        ));
                }, 10000);
            }
            //else
            //console.log(".onDataCenterMessage", "Channel " + server_packet.channel + " doesn't exist, skipping rejoin (extension has probably not started up and created a channel yet", server_packet.data);

            // -------------------------------------------------------------------------------------------------
            //                           IGNORING THESE MESSAGE (to save loging them)
            // -------------------------------------------------------------------------------------------------
        } else if (server_packet.type === "ChannelJoined"
            || server_packet.type === "ChannelCreated"
            || server_packet.type === "ChannelLeft"
        )
        {
            // just a blank handler for items we are not using to avoid message from the catchall
        }
        // ------------------------------------------------ unknown message type received -----------------------------------------------
        else
            console.log(".onDataCenterMessage", "Unhandled message type:", server_packet);
    }
    // ============================================================================
    //                           FUNCTION: SaveConfigToServer
    // ============================================================================
    function SaveConfigToServer ()
    {
        // saves our serverConfig to the server so we can load it again next time we startup
        sr_api.sendMessage(localConfig.DataCenterSocket,
            sr_api.ServerPacket(
                "SaveConfig",
                serverConfig.extensionname,
                serverConfig,
            ));
    }
    // ============================================================================
    //                           FUNCTION: SaveDataToServer
    // ============================================================================
    // Desription:save data on backend data store
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function SaveDataToServer ()
    {
        sr_api.sendMessage(localConfig.DataCenterSocket,
            sr_api.ServerPacket(
                "SaveData",
                serverConfig.extensionname,
                serverData));
    }
    // ===========================================================================
    //                           FUNCTION: SendSettingsWidgetSmall
    // ===========================================================================
    // Desription: Send the modal code back after setting the defaults according 
    // to our server settings
    // Parameters: channel to send data to
    // ----------------------------- notes ---------------------------------------
    // none
    // ===========================================================================
    function SendSettingsWidgetSmall (toextension)
    {
        fetch("modals/overlaysourcessettingswidgetsmall_placeholder.html")
            .then(response => response.text())
            .then(data => 
            {
                localConfig.smallsettingscode = data;
                let modalstring = localConfig.smallsettingscode

                // first lets update our modal to the current settings
                for (const [key, value] of Object.entries(serverConfig))
                {
                    // true values represent a checkbox so replace the "[key]checked" values with checked
                    if (value === "on")
                        modalstring = modalstring.replaceAll(key + "checked", "checked");
                    else if (typeof (value) == "string" || typeof (value) == "number")
                        modalstring = modalstring.replaceAll('"' + key + 'text"', '"' + value + '"');
                }
                updateAllOverlaySettings()
                // send the modal data to the server
                // send the modal data to the server
                sr_api.sendMessage(localConfig.DataCenterSocket,
                    sr_api.ServerPacket(
                        "ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "SettingsWidgetSmallCode",
                            serverConfig.extensionname,
                            modalstring,
                            serverConfig.channel,
                            toextension
                        ),
                        serverConfig.channel,
                        toextension
                    ));
            })
            .catch(error => console.log("LoadPages failed with error :", error))
    }
    // ===========================================================================
    //                           FUNCTION: SendSettingsWidgetLarge
    // ===========================================================================
    // Desription: Send the modal code back after setting the defaults according 
    // to our server settings
    // Parameters: channel to send data to
    // ----------------------------- notes ---------------------------------------
    // none
    // ===========================================================================
    function SendSettingsWidgetLarge (toextension)
    {
        //update the overlay servers with the current data
        localConfig.overlayfiles.forEach((ovly, i) => 
        {
            // check if we are loaded (on startup we may get to this point too soon)
            // if we havent loaded the overlay yet then reschedule the call
            if (typeof (localConfig.overlays[ovly]) != "undefined")
                updateOverlaySettings(ovly)
            else
            {
                setTimeout(() =>
                {
                    SendSettingsWidgetLarge(toextension)
                }, 500)
                return;
            }
        })
        fetch("modals/overlaysourcessettingswidgetlarge_placeholder.html")
            .then(response => response.text())
            .then(data => 
            {
                localConfig.largesettingscode = data;
                let modalstring = localConfig.largesettingscode

                // first lets update our modal to the current settings
                for (const [key, value] of Object.entries(serverConfig))
                {
                    // true values represent a checkbox so replace the "[key]checked" values with checked
                    if (value.indexOf("on") > -1)
                        modalstring = modalstring.replaceAll(key + "checked", "checked");
                    else if (typeof (value) == "string" || typeof (value) == "number")
                        modalstring = modalstring.replaceAll('"' + key + 'text', '"' + value);
                }


                /* add in the settings from all our loaded overlays */
                let overlaysnippetarea = ""
                localConfig.overlayfiles.forEach((ovly, i) => 
                {
                    overlaysnippetarea += localConfig.overlays[ovly].getSettingscode()
                })

                modalstring = modalstring.replace('overlaysources_overlaysnippets_go_here', overlaysnippetarea);
                // send the modal data to the server
                sr_api.sendMessage(localConfig.DataCenterSocket,
                    sr_api.ServerPacket(
                        "ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "SettingsWidgetLargeCode",
                            serverConfig.extensionname,
                            modalstring,
                            serverConfig.channel,
                            toextension
                        ),
                        serverConfig.channel,
                        toextension
                    ));
            })
            .catch(error => console.log("LoadPages failed with error :", error))
    }
    // ============================================================================
    //                           FUNCTION:updateAllOverlaySettings
    // ============================================================================
    function updateAllOverlaySettings ()
    {
        localConfig.overlayfiles.forEach((ovly, i) => 
        {
            if (typeof (localConfig.overlays[ovly]) != "undefined")
                updateOverlaySettings(ovly)
        })
    }
    // ============================================================================
    //                           FUNCTION:updateOverlaySettings
    // ============================================================================
    function updateOverlaySettings (ovly)
    {
        localConfig.overlays[ovly].setSettings(serverConfig)
    }
    // ============================================================================
    //                           FUNCTION: processAction
    // ============================================================================
    async function processAction (data)
    {

        let overlayname = data.type.replace("action_", "")
        let actionpacket = data.data
        // check the server passed us that as a valid file name
        if (localConfig.overlayfiles.indexOf(overlayname) > -1)
            localConfig.overlays[overlayname].update(actionpacket)
        else
            console.log("Process Action called for unknown overlay", overlayname)
    }
    // ============================================================================
    //                           FUNCTION: Load the overlays provided
    // ============================================================================
    async function LoadOverlays ()
    {
        for (let i = 0; i < localConfig.overlayfiles.length; i++)
        {
            let resendtriggers = false;
            // load the html as these are needed in the class constructor below
            await loadHTML("overlays/" + localConfig.overlayfiles[i] + "/" + localConfig.overlayfiles[i] + ".html")

            // create a new promise so we can wait for the load to call the constructor
            let scriptPromise = new Promise((resolve, reject) =>
            {
                const script = document.createElement('script');
                document.body.appendChild(script);
                script.onload = resolve;
                script.onerror = reject;
                script.async = true;
                script.src = "overlays/" + localConfig.overlayfiles[i] + "/" + localConfig.overlayfiles[i] + ".js";
            });
            // call the constructor once loaded
            scriptPromise.then(() => 
            {
                //create an instance of the new overlay class
                eval("localConfig.overlays[localConfig.overlayfiles[i]] = new " + localConfig.overlayfiles[i] + "()")
            })
                .then(() =>
                {
                    // add the triggers from this overlay
                    let trigger = localConfig.overlays[localConfig.overlayfiles[i]].getTriggers(serverConfig.channel)
                    if (trigger)
                    {
                        resendtriggers = true;
                        triggersandactions.triggers.push(trigger)
                    }
                    let action = localConfig.overlays[localConfig.overlayfiles[i]].getActions(serverConfig.channel)
                    if (action)
                    {
                        resendtriggers = true;
                        triggersandactions.actions.push(action)
                    }
                    // if we have added anything we need to resend out the triggers so extensions using them
                    // can update their lists
                    if (resendtriggers)
                    {
                        sendTriggersAndActions("")
                    }
                })
                ;
        }
    }
    async function loadHTML (filename)
    {
        document.getElementById("overlayarea").innerHTML += await fetchHtmlAsText(filename)
    }
    // ============================================================================
    // FUNCTION: fetchHtmlAsText
    // ============================================================================
    async function fetchHtmlAsText (url)
    {
        const response = await fetch(url);
        return await response.text();
    }
    // ============================================================================
    // FUNCTION: sendTriggersAndActions
    // ============================================================================
    function sendTriggersAndActions (to)
    {
        if (to == "")
        {
            sr_api.sendMessage(localConfig.DataCenterSocket,
                sr_api.ServerPacket("ChannelData",
                    serverConfig.extensionname,
                    sr_api.ExtensionPacket(
                        "TriggerAndActions",
                        serverConfig.extensionname,
                        triggersandactions,
                        serverConfig.channel,
                    ),
                    serverConfig.channel,
                )
            )
        }
        else
        {
            sr_api.sendMessage(localConfig.DataCenterSocket,
                sr_api.ServerPacket("ExtensionMessage",
                    serverConfig.extensionname,
                    sr_api.ExtensionPacket(
                        "TriggerAndActions",
                        serverConfig.extensionname,
                        triggersandactions,
                        serverConfig.channel,
                        to
                    ),
                    serverConfig.channel,
                    to
                )
            )
        }
    }
    // ============================================================================
    // FUNCTION: heartBeatCallback
    // ============================================================================
    function heartBeatCallback ()
    {
        if (serverConfig.overlaysourcesenabled == "off")
        {
            status = {
                connected: false,
                color: "red"
            }
        }
        {
            status = {
                connected: true,
                color: "green"
            }
        }

        sr_api.sendMessage(localConfig.DataCenterSocket,
            sr_api.ServerPacket("ChannelData",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "HeartBeat",
                    serverConfig.extensionname,
                    { connected: localConfig.connected },
                    serverConfig.channel),
                serverConfig.channel
            ),
        );
        localConfig.heartBeatHandle = setTimeout(heartBeatCallback, localConfig.heartBeatTimeout)
    }
</script>