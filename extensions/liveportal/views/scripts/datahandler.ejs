<!--
      StreamRoller_source Copyright 2023 "SilenusTA https://www.twitch.tv/olddepressedgamer"
 
      StreamRoller is an all in one streaming solution designed to give a single
      'second monitor' control page and allow easy integration for configuring
      content (ie. tweets linked to chat, overlays triggered by messages, hue lights
      controlled by donations etc)
 
      This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU Affero General Public License as published
      by the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
 
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU Affero General Public License for more details.
 
      You should have received a copy of the GNU Affero General Public License
      along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-->
<script src="/streamroller-message-api.cjs" onerror="scriptLoadFailed('streamroller-message-api.cjs')"></script>
<script src="/liveportal/scripts/triggers.js" onerror="scriptLoadFailed('triggers.js')"></script>
<!-- placehold we will use for inserting widgets-->

<%- include('../modals/liveportalsettingswidgetssmallplaceholder'); %>


<script>

    //"use strict"
    const default_serverConfig = {
        __version__: "0.1",
        // extensions vars
        extensionname: "liveportal",
        channel: "LIVE_PORTAL",
        logginglevel: "0",

        // extensions visibility on main page
        streamersonglistdisplay: "on",
        discordmodchatdisplay: "on",
        obsdisplay: "on",
        philipshuedisplay: "on",
        slalertsdisplay: "on",
        // obs settings
        obsdefaultstartscenename: "##Starting Soon",
        obsdefaultlivescenename: "##Game",
        obsdefaultintermissionscenename: "##Intermission",
        obsdefaultendscenename: "##StreamEnd",
        showprimaryscenes: "off",
        showsecondaryscenes: "off",
        showallscenes: "on",
        mutescene: "MIC-B1",
        muted: false,
        // chat window settings
        modchattomodwindow: "on",
        // discord settings
        modmessage_channel: "stream-mod-messages", // discord channel
        donations_channel: "announcements", // discord channel
        // alerts posting to discord
        follows: "off",
        raids: "off",
        hosts: "off",
        subs: "off",
        resubs: "off",
        giftsubs: "off",
        cloudbotredemption: "off",
        merch: "off",
        bits: "off",
        donations: "off",
        chatAsUsername: "user",

        // random facts / twitter settings
        randomfactsenabled: "on",
        randomfactstimeout: 1800000,//30 min

        randomfactstwitterstartenabled: "on",
        twitterstartenabled: "off",
        twitterstartmessage: "We're live twitch.tv/OldDepressedGamer",
        twitterstartmessage_x: "Come say Hi!",
        // max display size to maintain
        chatmessagebuffermaxsize: 300,
        discordmessagebuffermaxsize: 300,
        liveportal_restore_defaults: "off",
    };
    let serverConfig = structuredClone(default_serverConfig);
    let serverData = {}
    serverData.AllTriggersAndActions = { "default": { show: true, list: [] } };

    const localConfig =
    {
        OBSSceneslist: {},
        obslive: false, // set on a heartbeat from obs messages
        heartBeatTimeout: "6000",
        currentchatchannel: "",
        chatMessageBuffer: [],
        modMessageBuffer: [],
        mouseDown: 0,
        randomFact: "",
        twitchRandomFactHandle: null,
        timers: [],
        newTwitchChatBuffer: false,
        newDiscordChatBuffer: false,
        // streamersonglist variables
        setreamersonglist: { songlist: [], queue: { status: { "songsPlayedToday": "0" }, list: [] } },
        //philips hugh variables
        philipsHueSceneList: [],
        triggersAndActions: { descriptions: [], triggers: [], actions: [] }
    }
    const chatcolors =
    {
        //general use colors
        default_darkred_color: "darkred",
        default_greyout_color: "#adadad",
        default_system_color: "red",
        default_username_color: "#7097ff",//#6f42c1",
        default_timecode_color: "#757875",
        default_user_at_color: "red",
        default_text_bright_color: "white",
        default_sub_color: "#03b503",
        default_reward_color: "red",
        default_reward_bgcolor: "#fdff00",
        default_mod_action: "yellow",
        // yet to be processed colors
        default_TBD_background_color: "purple",
        default_TBD_text_color: "yellow",
    }

    // will hold the data center socket needed to send receive data
    // after refactoring the code this should hopefully not be needed anymore
    let DataCenterSocket = null;


    // truncates long log messages for easier reading. 
    const LOGGING_MAX_MESSAGE_LENGTH = 200

    //global data store for the app
    const livePortalData = {};
    livePortalData.extensions = {};
    // add our own card

    livePortalData.channellist = {};
    var host = '<%= host %>';
    var port = '<%= port %>';
    localConfig.heartBeatTimeout = parseInt('<%= heartbeat %>') + 1000;
    // check for mousedown as we might need to stop the chat scroll when the user is trying to scroll the box
    document.body.onmousedown = function () { localConfig.mouseDown = true }
    document.body.onmouseup = function () { localConfig.mouseDown = false }
    /* This block is to avoid the extensions being loaded before we have loaded our own settings. Websocket is quicker than our webpage */
    window.addEventListener('load',
        function ()
        {
            LoadPages
                .then((result) =>
                {
                    ConnectToDataCenter(host, port);
                    heartBeatCallback();
                })
                .catch((error) =>
                {
                    ConnectToDataCenter(host, port);
                    heartBeatCallback();
                    console.log('LoadPages error:', error.message);
                });

        });
    // ============================================================================
    //                           FUNCTION: Load our settings pages
    // ============================================================================
    const LoadPages = new Promise((resolve, reject) =>
    {
        try
        {
            // lets load our placeholder modal code. This is so we can update our own code the same way as the extensions
            livePortalData.extensions[serverConfig.extensionname] = { settingswidgetsmall_placeholder: "", settingswidgetlarge_placeholder: "" }
            fetch("liveportal/modals/liveportalsettingswidgetsmall_placeholder.html")
                .then(response => response.text())
                .then(data => 
                {
                    livePortalData.extensions[serverConfig.extensionname].settingswidgetsmall_placeholder = data;
                    fetch("liveportal/modals/liveportalsettingswidgetlarge_placeholder.html")
                        .then(response => response.text())
                        .then(data => 
                        {
                            livePortalData.extensions[serverConfig.extensionname].settingswidgetlarge_placeholder = data
                            resolve("Success");
                        })
                })
                .catch(error => console.log("LoadPages failed with error :", error))
        }
        catch (error)
        {
            reject(error)
        }

    });
    // ============================================================================
    //                           FUNCTION: scriptLoadFailed
    // ============================================================================
    // Desription: Runs when a script failes to load (404 error)
    function scriptLoadFailed (scriptname)
    {
        console.log("failed to load", scriptname, "reloading page")
        setTimeout(() =>
        {
            location.reload();
        }, 5000);
    }
    // ============================================================================
    //                           FUNCTION: ConnectToDataCenter
    // ============================================================================
    // Desription: Connect to the data center socket
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function ConnectToDataCenter (host, port)
    {
        try
        {
            DataCenterSocket = sr_api.setupConnection(onDataCenterMessage, onDataCenterConnect, onDataCenterDisconnect,
                host, port);
        } catch (err)
        {
            console.log("datahandler.initialise", "DataCenterSocket connection failed:", err);
        }
    }
    // ============================================================================
    //                           FUNCTION: onDataCenterDisconnect
    // ============================================================================
    // Desription: Received disconnect message
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function onDataCenterDisconnect (reason)
    {
        // remove all the other extensions but ours (lost datacenter means we only have ourselves to play with now)
        for (const key in livePortalData.extensions)
        {
            if (key != serverConfig.extensionname)
                delete livePortalData.extensions[key];
        }
        livePortalData.channellist = {};
    }
    // ============================================================================
    //                           FUNCTION: onDataCenterConnect
    // ============================================================================
    // Desription: Received connect message
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function onDataCenterConnect (socket)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "RequestConfig",
                serverConfig.extensionname
            ));

        //request software version
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "RequestSoftwareVersion",
                serverConfig.extensionname,
                serverConfig.channel
            ));

        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("RequestData", serverConfig.extensionname));

        // Request the stuff we need first here
        // We give the system some time to get things in and delay some of the longer stuff till the end (like the chat buffers) 
        // This is just to allow the extensions to get up and running
        setTimeout(() =>
        {
            RequestExtList();
            RequestChList();
            RequestLoggingLevel();
            setTimeout(() =>
            {
                RequestRandomFact();
                RequestTwitchAccountNames("twitchchat");
                setTimeout(() =>
                {
                    RequestChatBuffer("twitchchat");
                    setTimeout(() =>
                    {
                        RequestSongLists();
                        RquestPhilipsHueData();
                        RequestChatBuffer("discordchat");
                        if (serverConfig.randomfactsenabled === "on" && serverConfig.randomfactstimeout > 0)
                            twitchFactOfTheDay();
                    }, 1000);
                }, 500);
            }, 500);
        }, 1000);




    }
    // ============================================================================
    //                           FUNCTION: onDataCenterMessage
    // ============================================================================
    // Desription: Received message
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function onDataCenterMessage (server_packet)
    {
        // -------------------------------------------------------------------------------------------------
        //                  RECEIVED CONFIG
        // -------------------------------------------------------------------------------------------------
        if (server_packet.type === "ConfigFile")
        {

            // check it is our config
            if (server_packet.to === serverConfig.extensionname)
            {
                if (server_packet.data.__version__ != default_serverConfig.__version__)
                {
                    serverConfig = structuredClone(default_serverConfig);
                    console.log("\x1b[31m" + serverConfig.extensionname + " ConfigFile Updated", "The config file has been Updated to the latest version v" + default_serverConfig.__version__ + ". Your settings may have changed" + "\x1b[0m");
                }
                else
                {
                    // update our config
                    if (server_packet.data != "")
                    {
                        serverConfig = structuredClone(server_packet.data)
                    }
                }
                setCardsVisibility();
                // update our modal to match the new data
                UpdateOwnSettingsWidgetSmallData();
                UpdateOwnSettingsWidgetLargeData();

                ParseOBSScenesList(localConfig.OBSSceneslist);
                updatePhilipsHueDisplay();
                // update server log, mainly here if we have added new default options when a user
                // updates their version of streamroller
                SaveConfigToServer();
            }
        }
        else if (server_packet.type === "DataFile")
        {
            if (server_packet.data != "")
            {
                // check it is our data
                if (server_packet.to === serverConfig.extensionname)
                {
                    serverData = structuredClone(server_packet.data);
                    SaveDataToServer();
                }
            }
        }
        // -------------------------------------------------------------------------------------------------
        //                  RECEIVED CHANNEL LIST
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "ChannelList")
        {
            livePortalData.channellist = server_packet.data;
            livePortalData.channellist.forEach(element =>
            {
                if (element != serverConfig.channel)
                    sr_api.sendMessage(DataCenterSocket,
                        sr_api.ServerPacket(
                            "JoinChannel",
                            serverConfig.extensionname,
                            element
                        ));
            });
        }
        // -------------------------------------------------------------------------------------------------
        //                  RECEIVED LOGGING LEVEL
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "LoggingLevel")
        {
            if (serverConfig.logginglevel != server_packet.data)
            {
                serverConfig.logginglevel = server_packet.data
                UpdateOwnSettingsWidgetSmallData();
                UpdateOwnSettingsWidgetLargeData();
                //send modal to everyone to update their own copies of out model
                SendSettingsWidgetSmall("");
                SendSettingsWidgetLarge("");
            }
        }
        // -------------------------------------------------------------------------------------------------
        //                  RECEIVED LOGGING LEVEL
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "SoftwareVersion")
        {
            document.getElementById("softwareversion").innerHTML = server_packet.data;

        }
        // -------------------------------------------------------------------------------------------------
        //                   RECEIVED EXTENSION LIST
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "ExtensionList")
        {
            //load extension cards
            loadExtensionCards(server_packet.data);
            if (server_packet.data.includes("obs"))
            {
                RequestOBSScenes("obs");
            }
            // call the triggers code to request the triggers/actions from each extension in the list
            try
            {
                initTriggersAndActions(server_packet.data);
            }
            catch {
                console.log("initTriggersAndActions not loaded yet, recheduling")
                //probably not loaded yet
                setTimeout(() =>
                {
                    initTriggersAndActions(server_packet.data);
                }, 500);
            }
        }
        else if (server_packet.type === "ExtensionMessage")
        {
            let extension_packet = server_packet.data;
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED SETTINGS WIDGET SMALL REQUEST
            // -------------------------------------------------------------------------------------------------
            if (extension_packet.type == "SongQueue")
            {
                updateSingerSonglistQueue(extension_packet.data)
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED SETTINGS WIDGET SMALL REQUEST
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type == "SongList")
            {
                if (extension_packet.data && extension_packet.data.items)
                    updateSingerSonglistList(extension_packet.data.items)
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED SETTINGS WIDGET SMALL REQUEST
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "RequestSettingsWidgetSmallCode")
            {
                SendSettingsWidgetSmall(extension_packet.from);
            }

            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED SETTINGS WIDGET LARGE REQUEST
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "RequestSettingsWidgetLargeCode")
            {
                SendSettingsWidgetLarge(extension_packet.from);
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED EXTENSION MODAL CODE
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "SettingsWidgetSmallCode")
            {
                // we process our own submits so don't do anything with the updates we send out if they come 
                // back to us
                if (extension_packet.from != serverConfig.extensionname)
                {
                    livePortalData.extensions[extension_packet.from].settingswidgetsmall = extension_packet.data
                    addSettingsWidgetSmall(extension_packet.from);
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED EXTENSION MODAL CODE
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "SettingsWidgetLargeCode")
            {
                // we process our own submits so don't do anything with the updates we send out if they come 
                // back to us
                if (extension_packet.from != serverConfig.extensionname)
                {
                    livePortalData.extensions[extension_packet.from].settingswidgetlarge = extension_packet.data
                    addALLSettingsWidgetLarge();
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED MODAL DATA (someone hit submit on our dialog)
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "SettingsWidgetSmallData")
            {
                // check that it is not from us as we process our own code internally
                if (extension_packet.from != serverConfig.extensionname)
                {
                    // lets reset our config checkbox settings (modal will omit ones not
                    // checked in checkboxes so set them to "off" here first if you have them)
                    // set our config values to the ones in message
                    //for (const [key, value] of Object.entries(extension_packet.data))
                    //        serverConfig[key] = value;
                    for (const [key, value] of Object.entries(serverConfig))
                    {
                        //lets check our settings and send out updates as required
                        if (value === "on" && !extension_packet.data[key])
                            serverConfig[key] = "off";
                        else if (key === "randomfactstimeout")
                            serverConfig[key] = extension_packet.data[key] * 60000
                        else if (key in extension_packet.data)
                            serverConfig[key] = extension_packet.data[key];
                    }

                    changeServerLogging(serverConfig.logginglevel)
                    // save our data to the server for next time we run
                    SaveConfigToServer();
                    //lets update our modals
                    UpdateOwnSettingsWidgetSmallData();
                    UpdateOwnSettingsWidgetLargeData();
                    // update anyone that may have out modal
                    SendSettingsWidgetSmall("");
                    SendSettingsWidgetLarge("");

                    ParseOBSScenesList(localConfig.OBSSceneslist);
                    // setup timeout for facts on stream
                    if (serverConfig.randomFactsEnabled === "on" && serverConfig.randomFactsTimeout > 0)
                        twitchFactOfTheDay();

                }
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED MODAL DATA (someone hit submit on our dialog (should be sent directly to us))
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "SettingsWidgetLargeData")
            {
                // check that it is not from us as we process our own code internally
                if (extension_packet.from != serverConfig.extensionname)
                {
                    if (extension_packet.data.liveportal_restore_defaults == "on")
                    {
                        serverConfig = structuredClone(default_serverConfig);
                        return;
                    }
                    else
                    {
                        for (const [key, value] of Object.entries(serverConfig))
                        {
                            //lets check our settings and send out updates as required
                            if (value === "on" && !extension_packet.data[key])
                                serverConfig[key] = "off";
                            else if (key === "randomfactstimeout")
                                serverConfig[key] = extension_packet.data[key] * 60000
                            else if (key in extension_packet.data)
                                serverConfig[key] = extension_packet.data[key];
                        }
                    }
                    changeServerLogging(serverConfig.logginglevel)
                    // save our data to the server for next time we run
                    SaveConfigToServer();
                    //lets update our modals
                    UpdateOwnSettingsWidgetSmallData();
                    UpdateOwnSettingsWidgetLargeData();
                    // update anyone that may have out modal
                    SendSettingsWidgetSmall("");
                    SendSettingsWidgetLarge("");

                    ParseOBSScenesList(localConfig.OBSSceneslist);
                    // setup timeout for facts on stream
                    if (serverConfig.randomFactsEnabled === "on" && serverConfig.randomFactsTimeout > 0)
                        twitchFactOfTheDay();

                }
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED Scenes list from OBS
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "ScenesList")
            {
                ParseOBSScenesList(extension_packet.data)
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED Twitch chat buffer
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "TwitchChatBuffer")
            {
                localConfig.newTwitchChatBuffer = true
                // recreate our buffer
                processTwitchChatBuffer(extension_packet.data)
                    .then(() =>
                        // display the chat buffer
                        displayChatMessages()

                    )
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED Twitch chat buffer
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "UserAccountNames")
            {
                processTwitchAccountNames(extension_packet)
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED Discord chat buffer
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "DiscordChatBuffer")
            {
                localConfig.newDiscordChatBuffer = true
                // recreate our buffer
                processDiscordChatBuffer(extension_packet.data)
                    .then(() =>
                        // display the chat buffer
                        displayChatMessages()

                    )
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED chatbot message directly to us
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "AIChatbotResponse")
            {
                // these are responses from chatbot that got sent directly (ie not as chatbot chat functionality)
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket("ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "action_SendChatMessage",
                            serverConfig.extensionname,
                            // need to read accounts from twitchchat ext and give an option to chose who to send the message as
                            {
                                account: "bot",
                                message: extension_packet.data.response,
                                'message-type': "AIchatbotmessage"
                            },
                            "",
                            "twitchchat"),
                        "",
                        "twitchchat"
                    ));
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED trigger and action data
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "TriggerAndActions")
            {
                if (extension_packet.to == serverConfig.extensionname)
                    receivedTrigger(extension_packet.data)
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED Unhandled extension message
            // -------------------------------------------------------------------------------------------------
            else
            {
                //    console.log(".onDataCenterMessage", "ExtensionMessage not handled ", extension_packet.type, " from ", extension_packet.from);
            }
        }
        // -------------------------------------------------------------------------------------------------
        //                   RECEIVED CHANNEL DATA
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "ChannelData")
        {
            let extension_packet = server_packet.data;
            // -------------------------------------------------------------------------------------------------
            //                           CheckForTrigger
            // -------------------------------------------------------------------------------------------------
            if (extension_packet.type.startsWith("trigger_"))
                CheckTriggers(extension_packet)
            // -------------------------------------------------------------------------------------------------
            //                           HEARTBEAT
            // -------------------------------------------------------------------------------------------------
            if (extension_packet.type === "HeartBeat")
            {
                //check if we have this extension
                if (typeof (livePortalData.extensions[extension_packet.from]) !== "undefined")
                {
                    //clear the previous timeout handle
                    clearTimeout(livePortalData.extensions[extension_packet.from].heartBeatHandle);
                    // setup a new timeout for this extension
                    livePortalData.extensions[extension_packet.from].heartBeatHandle = setTimeout(() => 
                    {
                        heartBeatCallback(extension_packet.from)
                    },
                        localConfig.heartBeatTimeout);

                    // set the on screen status for this extension
                    setExtensionStatus(extension_packet.from, extension_packet.data)

                }
                else
                {
                    console.log("missing extensions, requesting again")
                    RequestExtList();
                    RequestChList();
                }
            }
            else if (extension_packet.type === "TriggerAndActions")
            {
                receivedTrigger(extension_packet.data)
            }
            // -------------------------------------------------------------------------------------------------
            //                           STREAMLABS_ALERT
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel === "STREAMLABS_ALERT")
            {
                if (extension_packet.data != undefined)
                    ProcessStreamlabsAlert(extension_packet);
            }
            // -------------------------------------------------------------------------------------------------
            //                           CHATMOOD_CHANNEL
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel === "CHATMOOD_CHANNEL")
                console.log("CHATMOOD_CHANNEL received", extension_packet.data)
            // -------------------------------------------------------------------------------------------------
            //                           TWITCH_CHAT
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "TWITCH_CHAT")
            {
                if (extension_packet.type === "ChatMessage")
                {
                    parseTwitchChatMessage(extension_packet.data);
                    displayChatMessages();
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                           DISCORD_CHAT
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "DISCORD_CHAT")
            {
                if (extension_packet.type === "trigger_DiscordMessageReceived")
                {
                    parseDiscordChatMessage(server_packet.data.data);
                    //displayDiscordMessages(server_packet);
                    displayChatMessages();
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                           TIMERS_CHANNEL
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "TIMERS")
            {
                if (extension_packet.type === "trigger_TimerRunning")
                {
                    processTimers(extension_packet.data.parameters);
                    UpdateOBSDefaultButtons();
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                           OBS_CHANNEL
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "OBS_CHANNEL")
            {
                if (extension_packet.type === "ScenesList")
                    ParseOBSScenesList(extension_packet.data)
                else if (extension_packet.type === "trigger_SceneChanged")
                {
                    localConfig.OBSSceneslist.current = extension_packet.data.parameters.sceneName;
                    ParseOBSScenesList(localConfig.OBSSceneslist);
                }
                else if (extension_packet.type === "OBSStats")
                {
                    // need to check in case we missed the start message (stream already running when we load the page)
                    if (!localConfig.obslive)
                    {
                        localConfig.obslive = extension_packet.data.obslive;
                        OBSLiveCheck();
                    }

                    ProcessOBSStats(extension_packet.data);
                }
                else if (extension_packet.type === "trigger_StreamStarted")
                {
                    localConfig.obslive = true;
                    OBSLiveCheck();
                    // send tweet to say we are live
                    if (serverConfig.twitterstartenabled)
                        postMessageToTwitter(serverConfig.twitterstartmessage, serverConfig.twitterstartmessage_x);
                }
                else if (extension_packet.type === "trigger_StreamStopped")
                {
                    localConfig.obslive = false;
                    OBSLiveCheck();
                }
                else if (extension_packet.type === "MuteStatus")
                {
                    if (extension_packet.data.scene === serverConfig.mutescene)
                    {
                        serverConfig.muted = extension_packet.data.muted
                        addOBSMuteButton(serverConfig.muted)
                        OBSLiveCheck();
                    }
                }
                else
                    console.log(".onDataCenterMessage", "OBS_CHANNEL message ignored ", extension_packet.type, " from ", extension_packet.from);
            }
            else if (server_packet.dest_channel == "STREAMERSONGLIST_CHANNEL")
            {
                if (extension_packet.type == "SongQueue")
                    updateSingerSonglistQueue(extension_packet.data)
                else if (extension_packet.type == "SongList")
                    updateSingerSonglistList(extension_packet.data.items)
            }
            else if (server_packet.dest_channel == "PHILIPSHUE_CHANNEL")
            {
                // -------------------------------------------------------------------------------------------------
                //                   RECEIVED Discord chat buffer
                // -------------------------------------------------------------------------------------------------
                if (extension_packet.type === "PhilipsHueScenes")
                {
                    localConfig.philipsHueSceneList = extension_packet.data
                    processPhilipsHueScenes();
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                           IGNORED CHANNELS
            //                      These are most likely ones we only use for triggers and alerts
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "RANDOMFACT_CHANNEL")
            {
                // -------------------------------------------------------------------------------------------------
                //                   RECEIVED Received random fact
                // -------------------------------------------------------------------------------------------------
                if (extension_packet.type === "trigger_RandomFact")
                    processRandomFact(extension_packet.data.parameters.randomFact);
            }
            // -------------------------------------------------------------------------------------------------
            //                           IGNORED CHANNELS
            //                      These are most likely ones we only use for triggers and alerts
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "CHATBOT_CHANNEL")
            {

                if (extension_packet.type === "AIChatbotResponse")
                {
                    // these are responses from chatbot that got sent directly (ie not as chatbot chat functionality)
                    sr_api.sendMessage(DataCenterSocket,
                        sr_api.ServerPacket("ExtensionMessage",
                            serverConfig.extensionname,
                            sr_api.ExtensionPacket(
                                "action_SendChatMessage",
                                serverConfig.extensionname,
                                // need to read accounts from twitchchat ext and give an option to chose who to send the message as
                                {
                                    account: "bot",
                                    message: extension_packet.data.response,
                                    'message-type': "AIchatbotmessage"
                                },
                                "",
                                "twitchchat"),
                            "",
                            "twitchchat"
                        ));
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                           UNHANDLED CHANNEL DATA
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "MSFS2020_CHANNEL")
            {
                //just igore these messages
            }
            else
            {
                console.log(".onDataCenterMessage", "Channel Data " + server_packet.dest_channel + " not handled");
            }
        }
        // -------------------------------------------------------------------------------------------------
        //                           UNKNOWN CHANNEL MESSAGE RECEIVED
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "UnknownChannel")
        {
            //channel might not exist yet, extension might still be starting up so lets rescehuled the join attempt
            // need to add some sort of flood control here so we are only attempting to join one at a time
            if (server_packet.data != "" && server_packet.channel != undefined)
            {
                setTimeout(() =>
                {

                    sr_api.sendMessage(DataCenterSocket,
                        sr_api.ServerPacket(
                            "JoinChannel",
                            serverConfig.extensionname,
                            server_packet.data
                        ));
                }, 10000);
            }
        }
        else if (server_packet.type === "ChannelJoined"
            || server_packet.type === "ChannelCreated"
            || server_packet.type === "ChannelLeft"
            || server_packet.type === "UnknownExtension" // extension may not have loaded yet
        )
        {
            // just a blank handler for items we are not using to avoid message from the catchall
        }
        // ------------------------------------------------ unknown message type received -----------------------------------------------
        else
            console.log(".onDataCenterMessage", "Unhandled message type:", server_packet);
    }
    // ============================================================================
    //                           FUNCTION: heartBeatCallback
    // ============================================================================
    // Desription: started when we get a heartbeat and used to mark the extension as down if it expires
    // Parameters: extension name and the state (true fals to represent status)
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function heartBeatCallback (extensionname)
    {
        setExtensionStatus(extensionname, false);
    }
    // ============================================================================
    //                           FUNCTION: SaveConfigToServer
    // ============================================================================
    function SaveConfigToServer ()
    {
        // saves our serverConfig to the server so we can load it again next time we startup
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "SaveConfig",
                serverConfig.extensionname,
                serverConfig,
            ));
    }
    // ============================================================================
    //                           FUNCTION: SaveDataToServer
    // ============================================================================
    // Desription:save data on backend data store
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function SaveDataToServer ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "SaveData",
                serverConfig.extensionname,
                serverData));
    }
    // ============================================================================
    //                           FUNCTION: loadExtensionCards
    // ============================================================================
    // Desription: display message in allmessages card
    // Parameters: list of extension names
    // ----------------------------- notes ----------------------------------------
    // There is a bug here. If the backend restarts and the page isn't 
    // refreshed then any callbacks from the froms will fail. fix was to 
    // force a fresh of the page when a new extension list comes in. Not very
    // smooth :(
    // ===========================================================================
    function loadExtensionCards (extensions)
    {
        extensions.sort()
        // First we create all the links (these may be changed below if the extension has provided a modal box)
        var html = "<div>";
        for (var i = 0; i < extensions.length; i++)
        {
            // if we dont currently have that extension add it to the list and request the code for its settings
            // displays if it has them (done via callbacks over the websocket)
            if (typeof livePortalData.extensions[extensions[i]] == "undefined")
            {
                livePortalData.extensions[extensions[i]] = {};
                livePortalData.extensions[extensions[i]].display = false;
                RequestSettingsWidgetSmallsCode(extensions[i]);
                RequestSettingsWidgetLargeCode(extensions[i]);

            }
            html += "<div id='" + extensions[i] + "_visibility_settingswidgetsmall' style='display: none;'> <span id='" + extensions[i] + "_status' class='extensioncardicon'>&#x2B24</span>";
            html += " <span id='" + extensions[i] + "_settingslinkname'>" + extensions[i] + "</span></div>";

        };
        //html += "</ul>";
        html += "</div>";
        document.getElementById("ExtensionsListCard").getElementsByClassName("card-title")[0].innerHTML = "ExtensionsList";
        document.getElementById("ExtensionsListCard").getElementsByClassName("card-text")[0].innerHTML = html;

        // lets check if we have a previous settingswidgets cards for this extension and if so add it to the link above
        for (var i = 0; i < extensions.length; i++)
        {
            if (livePortalData.extensions[extensions[i]].settingswidgetsmall)
                addSettingsWidgetSmall(extensions[i])
        }
        //        if (livePortalData.extensions[extensions[i]].settingswidgetlarge)
        addALLSettingsWidgetLarge()

    }
    // ===========================================================================
    //                           FUNCTION: SendSettingsWidgetSmall
    // ===========================================================================
    // Desription: Send the modal code back after setting the defaults according 
    // to our server settings
    // Parameters: channel to send data to
    // ----------------------------- notes ---------------------------------------
    // none
    // ===========================================================================
    function SendSettingsWidgetSmall (toextension)
    {
        let modalstring = livePortalData.extensions[serverConfig.extensionname].settingswidgetsmall;
        // first lets update our modal to the current settings
        for (const [key, value] of Object.entries(serverConfig))
        {
            // true values represent a checkbox so replace the "[key]checked" values with checked
            if (value === "on")
                modalstring = modalstring.replaceAll(key + "checked", "checked");
            else if (typeof (value) == "string" || typeof (value) == "number")
                modalstring = modalstring.replaceAll('"' + key + 'text"', '"' + value + '"');
        }
        // send the modal data to the server
        // send the modal data to the server
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "SettingsWidgetSmallCode",
                    serverConfig.extensionname,
                    modalstring,
                    serverConfig.channel,
                    toextension
                ),
                serverConfig.channel,
                toextension
            ));
    }
    // ===========================================================================
    //                           FUNCTION: SendSettingsWidgetLarge
    // ===========================================================================
    // Desription: Send the modal code back after setting the defaults according 
    // to our server settings
    // Parameters: channel to send data to
    // ----------------------------- notes ---------------------------------------
    // none
    // ===========================================================================
    function SendSettingsWidgetLarge (toextension)
    {
        let modalstring = livePortalData.extensions[serverConfig.extensionname].settingswidgetlarge;
        // first lets update our modal to the current settings
        for (const [key, value] of Object.entries(serverConfig))
        {
            // true values represent a checkbox so replace the "[key]checked" values with checked
            if (value === "on")
                modalstring = modalstring.replaceAll(key + "checked", "checked");
            else if (typeof (value) == "string" || typeof (value) == "number")
                modalstring = modalstring.replaceAll('"' + key + 'text"', '"' + value + '"');
        }
        // send the modal data to the server
        // send the modal data to the server
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "SettingsWidgetLargeCode",
                    serverConfig.extensionname,
                    modalstring,
                    serverConfig.channel,
                    toextension
                ),
                serverConfig.channel,
                toextension
            ));
    }
    // ============================================================================
    //                           FUNCTION: addSettingsWidgetSmall
    // ============================================================================
    // Desription: Add the modal code from the extension to the link
    // Parameters: 
    //          xname - name of extension
    //          data  - data to add
    // ----------------------------- notes ----------------------------------------
    // None
    // ===========================================================================
    function addSettingsWidgetSmall (xname)
    {
        // only update modals if we have received the extension name from the server
        if (livePortalData.extensions[xname])
        {
            let data = livePortalData.extensions[xname].settingswidgetsmall
            // grab the placeholder code we user to save us from writing all the code from scratch :P
            let modalbox = document.getElementById("LivePortalSettingsWidgetsSmallPlaceholder").children[0];
            // check we have a visibity link, if not we don't have a container for this model to go in
            if (document.getElementById(xname + "_visibility_settingswidgetsmall") == null)
                return
            document.getElementById(xname + "_visibility_settingswidgetsmall").style.display = "";

            // grab the <li> element for this extension added in when we got the extension list
            let extLiTag = document.getElementById(xname + "_settingslinkname");


            // remove the previous event listener (if there was one)
            $('#' + xname + "_settingswidgetsmallmodal").off('submit');

            //load the modal data we have been sent into the tag
            extLiTag.innerHTML = modalbox.innerHTML;
            // setup the link to show the dialog
            extLiTag.getElementsByClassName("ext-modal-link")[0].href = "#" + xname + "_settingswidgetsmallmodal";
            extLiTag.getElementsByClassName("ext-modal-link")[0].innerHTML = xname;
            extLiTag.getElementsByClassName("modal")[0].id = xname + "_settingswidgetsmallmodal";
            // set the data from the extension
            document.getElementById(xname + "_settingswidgetsmallmodal").innerHTML = data;

            // add a callback handle when form is submitted
            $('#' + xname + "_settingswidgetsmallmodal").on('submit', function (event)
            {
                event.preventDefault();
                // if it is our own modal that has changed (another page has submitted one)
                // we need to process it ourselves first
                if (xname == serverConfig.extensionname)
                {
                    // process this data oursleves first
                    processOwnSettingsWidgetSmallSubmit(xname);
                    // now it is processed we can parse it
                    UpdateOwnSettingsWidgetSmallData()
                    UpdateOwnSettingsWidgetLargeData()

                    // update anyone that has our modal
                    SendSettingsWidgetSmall("");
                    SendSettingsWidgetLarge("");

                    ParseOBSScenesList(localConfig.OBSSceneslist);
                    setCardsVisibility();
                }
                else
                    parseExtensionModalData(xname, xname + "_settingswidgetsmallmodal");
                return false;
            });
            document.getElementById(xname + "_visibility_settingswidgetsmall").style.display = "block"

        }
        // need to update the mode in case we have received a light mode 
        // modal and we are in dark mode
        refreshDarkMode();
    }
    // ============================================================================
    //                           FUNCTION: addSettingsWidgetLarge
    // ============================================================================
    // Desription: Add the modal code from the extension
    // Parameters: 
    //          xname - name of extension
    //          data  - data to add
    // ----------------------------- notes ----------------------------------------
    // None
    // ===========================================================================
    function addALLSettingsWidgetLarge ()
    {
        let first = true;
        // clear the existing page data
        document.getElementById("SettingsPageTabs").innerHTML = "";
        document.getElementById("SettingsPageContent").innerHTML = "";
        // add/replace the existing data for this extensions
        //livePortalData.extensions[newwidgetname].settingswidgetlarge = data
        // loop through all our extensions and add them to the tabs and insert the widget in to the page

        Object.entries(livePortalData.extensions).forEach(([xname, stuff]) =>
        {
            if (stuff.settingswidgetlarge)
            {
                // ################# ADD TABS ##############
                if (first)
                {
                    document.getElementById("SettingsPageTabs").innerHTML += "<li class='nav-item' id='" + xname + "_settingswidgetlargetab'>\n<a class='nav-link active bg-light text-dark' id='" + xname + "_settingswidgetlargelink' data-toggle='tab' href='#" + xname + "_settingswidgetlargecontent'>" + xname + "</a>\n</li>"
                }
                else
                    document.getElementById("SettingsPageTabs").innerHTML += "<li class='nav-item' id='" + xname + "_settingswidgetlargetab'>\n<a class='nav-link bg-light text-dark' id='" + xname + "_settingswidgetlargelink' data-toggle='tab' href='#" + xname + "_settingswidgetlargecontent'>" + xname + "</a>\n</li>"

                //livePortalData.extensions[xname].settingswidgetlarge = document.getElementById(xname).innerHTML
                if (first)
                {
                    first = false;
                    document.getElementById("SettingsPageContent").innerHTML += "<div class='tab-pane fade show active' role='tabpanel'  id='" + xname + "_settingswidgetlargecontent'>" + stuff.settingswidgetlarge + "</div>"
                }
                else
                    document.getElementById("SettingsPageContent").innerHTML += "<div class='tab-pane fade' role='tabpanel' id='" + xname + "_settingswidgetlargecontent'>" + stuff.settingswidgetlarge + "</div>"

                setTimeout(() =>
                {
                    $('#' + xname + "_settingsform").off('submit');
                    $('#' + xname + "_settingsform").on('submit', function (event)
                    {
                        event.preventDefault();
                        // if it is our own modal that has changed (another page has submitted one
                        // we need to process it ourselves first
                        if (xname == serverConfig.extensionname)
                        {
                            // process this data oursleves first
                            processOwnSettingsWidgetLargeSubmit(xname);
                            // now it is processed we can parse it
                            UpdateOwnSettingsWidgetSmallData()
                            UpdateOwnSettingsWidgetLargeData()

                            // update anyone that has our modal
                            SendSettingsWidgetSmall("");
                            SendSettingsWidgetLarge("");

                            ParseOBSScenesList(localConfig.OBSSceneslist);
                            setCardsVisibility();
                        }
                        else
                            parseExtensionModalData(xname, xname + "_settingsform");

                        $("#live-tab").tab('show');
                        return false;
                    });
                    $('#' + xname + "_settingsform").find('#closeSettings').on('click', function (event)
                    {
                        event.preventDefault();
                        $("#live-tab").tab('show');
                        return false;
                    });

                }, 200);
            }
        });

        setTimeout(() =>
        {
            $('#SettingsPageTabs a').off('click')
            $('#SettingsPageTabs a').click(function (e)
            {
                e.preventDefault();
                $(this).tab('show');
            })
            // need to update the mode in case we have received a light mode 
            // modal and we are in dark mode, done here in case we arn't loaded yet
            refreshDarkMode();
        }
            , 200);


    }
    // ============================================================================
    //                           FUNCTION: setExtensionStatus
    // ============================================================================
    function setExtensionStatus (extension, status)
    {
        /* extensions can send vaious data here. The priority is
        1) if they provide a color just use that
        2) if they are not connected or status is false set red // backwards compatability here
        3) if they have a readonly flag set to true set orange // for chat mostly
        4) if connected or status is true set green
        5) otherwise set red

        */
        if (status.color)
            document.getElementById(extension + "_status").style = "color:" + status.color;
        else if (!status.connected || status == "false")
            document.getElementById(extension + "_status").style = "color:red";
        else if (status.readonly)
            document.getElementById(extension + "_status").style = "color:orange";
        else if (status.connected || status == true)
            document.getElementById(extension + "_status").style = "color:green";
        else
            document.getElementById(extension + "_status").style = "color:red";
        document.getElementById(extension + "_visibility_settingswidgetsmall").style.display = "";
    }
    // ============================================================================
    //                           FUNCTION: UpdateOBSDefaultButtons
    // ============================================================================
    function UpdateOBSDefaultButtons ()
    {
        var element = document.getElementById("OBSDefaultButtons");
        element.textContent = "";

        if (localConfig.timers.StartCountdownTimer != undefined && localConfig.timers.StartCountdownTimer > 0)
        {
            let minutes = Math.floor(localConfig.timers.StartCountdownTimer / 60);
            let seconds = localConfig.timers.StartCountdownTimer - (minutes * 60);
            addOBSSceneButton(element, minutes.toString().padStart(2, '0') + ":" + seconds.toString().padStart(2, '0'), serverConfig.obsdefaultstartscenename, localConfig.OBSSceneslist.current)
        }
        else
            addOBSSceneButton(element, "Start", serverConfig.obsdefaultstartscenename, localConfig.OBSSceneslist.current)
        addOBSSceneButton(element, "Live", serverConfig.obsdefaultlivescenename, localConfig.OBSSceneslist.current)
        addOBSSceneButton(element, "Intermission", serverConfig.obsdefaultintermissionscenename, localConfig.OBSSceneslist.current)
        addOBSSceneButton(element, "End", serverConfig.obsdefaultendscenename, localConfig.OBSSceneslist.current)
    }
    // ============================================================================
    //                           FUNCTION: ParseOBSScenesList
    // ============================================================================
    function ParseOBSScenesList (data)
    {
        let primaryScenes = data.main;
        let secondaryScenes = data.secondary;
        let restScenes = data.rest;
        let foundmutedscene = false;
        // remove the existing buttons
        var element = document.getElementById("OBSButtons");
        //remove the old buttons
        element.textContent = ""
        //store the data incase the user updated what they want to display
        localConfig.OBSSceneslist = data;
        // update default buttons
        UpdateOBSDefaultButtons();

        // always show the primary scene list
        if (typeof (primaryScenes) !== "undefined" &&
            (serverConfig.showallscenes === "on" || serverConfig.showprimaryscenes === "on")
        )
        {
            primaryScenes.forEach((scene) => 
            {
                addOBSSceneButton(element, scene.displayName, scene.sceneName, data.current);
                if (scene.displayName === serverConfig.mutescene)
                {
                    foundmutedscene = true;
                    addOBSMuteButton(scene.muted);
                }
            });
        }
        // if we have all or secondory selected to show then show both 'secondary' list and 'rest' list
        if (typeof (secondaryScenes) !== "undefined" && (serverConfig.showallscenes === "on" || serverConfig.showsecondaryscenes === "on"))
        {
            secondaryScenes.forEach((scene) => 
            {
                addOBSSceneButton(element, scene.displayName, scene.sceneName, data.current);
                if (scene.displayName === serverConfig.mutescene)
                {
                    foundmutedscene = true;
                    addOBSMuteButton(scene.muted);
                }
            });
        }
        // only show remaining scenes if all is set
        if (typeof (restScenes) !== "undefined" && serverConfig.showallscenes === "on")
        {
            restScenes.forEach((scene) => 
            {
                addOBSSceneButton(element, scene.displayName, scene.sceneName, data.current)
                if (scene.displayName === serverConfig.mutescene)
                {
                    foundmutedscene = true;
                    addOBSMuteButton(scene.muted);
                }
            })
            // Add mute button
        }
        if (!foundmutedscene)
            addOBSMuteButton(serverConfig.muted);
        // check if we are live and set the colors accordingly.
        OBSLiveCheck();
        //update any filters we may have
        UpdateOBSFilters();
    }
    // ============================================================================
    //                           FUNCTION: addOBSSceneButton
    // ============================================================================
    function addOBSSceneButton (element, displayname, scenename, current)
    {
        let button = document.createElement('input');
        button.type = 'button';
        button.value = displayname;
        if (scenename === current)
            button.classList = "btn btn-success";
        else
            button.classList = "btn btn-secondary";
        button.addEventListener('click', function ()
        {
            event.preventDefault();
            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket(
                    "ExtensionMessage",
                    serverConfig.extensionname,
                    sr_api.ExtensionPacket(
                        "action_ChangeScene",
                        serverConfig.extensionname,
                        scenename,
                        "",
                        "obs"
                    ),
                    "",
                    "obs"
                )
            )
            return false;
        }, false);

        element.appendChild(button);
    }
    // ============================================================================
    //                           FUNCTION: addOBSMuteButton
    // ============================================================================
    function addOBSMuteButton (muted)
    {
        let button = document.createElement('input');
        button.type = 'button';
        button.value = "Mute";
        if (muted)
            button.classList += "btn btn-danger";
        else
            button.classList += "btn btn-secondary";
        button.addEventListener('click', function ()
        {
            event.preventDefault();
            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket(
                    "ExtensionMessage",
                    serverConfig.extensionname,
                    sr_api.ExtensionPacket(
                        "action_ToggleMute",
                        serverConfig.extensionname,
                        { sourceName: serverConfig.mutescene },
                        "",
                        "obs"
                    ),
                    "",
                    "obs"
                )
            )
            return false;
        }, false);

        //remove the old button
        document.getElementById("OBSMute").textContent = ""
        // add the new one
        document.getElementById("OBSMute").appendChild(button);
    }
    // ============================================================================
    //                           FUNCTION: OBSLiveCheck
    // ============================================================================
    function OBSLiveCheck ()
    {
        let livebackbround = document.getElementById("OBSControllsCard");
        // check if we are live
        if (localConfig.obslive)
        {
            // currently set to live so lets set the background to green
            // remove the normal colors
            livebackbround.classList.remove('bg-light');
            livebackbround.classList.remove('text-light');
            livebackbround.classList.remove('bg-dark');
            livebackbround.classList.remove('text-dark');
            livebackbround.style["background-color"] = "#013301";
            livebackbround.style["color"] = "white";
            // remove any previous colors for the background
        }
        else
        {
            // not live anymore so set the background back to normal
            document.getElementById("OBSStrain").style.removeProperty("background-color")
            // background is set in the navbar partial code and uses local storage. should probably update this and move it here
            if (localStorage.getItem("darkmode") === "true")
            {
                livebackbround.classList.remove('bg-light');
                livebackbround.classList.remove('text-dark');
                livebackbround.classList.add('bg-dark');
                livebackbround.classList.add('text-light');
            }
            else
            {
                livebackbround.classList.remove('bg-dark');
                livebackbround.classList.remove('text-light');
                livebackbround.classList.add('bg-light');
                livebackbround.classList.add('text-dark');
            }
        }
    }
    // ============================================================================
    //                           FUNCTION: ProcessOBSStats
    // ============================================================================
    // Desription:save config on backend data store
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // 
    /*{
  "averageFrameTime": 24.81013,
  "bytesPerSec": 60795,
  "cpuUsage": 18.0699481865285,
  "freeDiskSpace": 348106.8203125,
  "kbitsPerSec": 474,
  "memoryUsage": 468.78125,
  "numDroppedFrames": 0,
  "numTotalFrames": 44,
  "outputSkippedFrames": 0,
  "outputTotalFrames": 57,
  "previewOnly": false,
  "recordingPaused": false,
  "renderMissedFrames": 4,
  "renderTotalFrames": 2932,
  "replayBufferActive": false,
  "streamTimecode": "00:00:01.466",
  "totalStreamTime": 1,
  "updateType": "StreamStatus"
  */

    // ===========================================================================
    function ProcessOBSStats (data)
    {
        var hour = "";
        var min = "";
        var sec = "";
        var Uptime = "";
        var missedframestxt = "";
        var skippedframestxt = "";

        if (localConfig.obslive)
        {
            //let rate = data.outputBytes;
            let strain = data.outputCongestion; // red/green/amber icon needed
            var straincolor = (255 / 1 * strain);
            var Uptime = "";

            // saves our serverConfig to the server so we can load it again next time we startup
            if (data.totalStreamTime > 0)
            {
                hour = Math.floor((data.totalStreamTime / 1000 / 3600) << 0)
                min = Math.floor((data.totalStreamTime / 1000 / 60) << 0)
                sec = Math.floor((data.totalStreamTime / 1000) % 60);
                if (hour > 0)
                    Uptime = "Uptime:<BR>" + hour + ":" + (min - (hour * 60)) + ":" + sec
                else
                    Uptime = "Uptime:<BR>" + hour + ":" + min + ":" + sec
            }

            document.getElementById("OBSUptime").innerHTML = Uptime;
            //document.getElementById("OBSRate").innerHTML = "Rate:<BR>" + rate + " kb/s";

            let missedframes = data.renderSkippedFrames;
            let skippedframes = data.outputSkippedFrames;
            // add coloring if we drop too many frames and we also truncat the numbers if over 10k
            if (missedframes > 1000)
            {
                if (missedframes > 10000)
                    missedframestxt = (~~(missedframes / 1000)) + "k"
                missedframestxt = "<span style='color:red'>Render errors:<BR>" + missedframestxt + "</span>";
            }
            else if (missedframes > 0)
                missedframestxt = "<span style='color:orange'>Render errors:<BR>" + missedframes + "</span>";
            else
                missedframestxt = "<span style='color:green'>Render errors:<BR>" + missedframes + "</span>";

            if (skippedframes > 1000)
            {
                if (skippedframes > 10000)
                    skippedframestxt = (~~(skippedframes / 1000)) + "k"
                skippedframestxt = "<span style='color:red'>Network frames errors:<BR>" + skippedframestxt + "</span>";
            }
            else if (skippedframes > 0)
                skippedframestxt = "<span style='color:orange'>Network frames errors:<BR>" + skippedframes + "</span>";
            else
                skippedframestxt = "<span style='color:green'>Network frames errors:<BR>" + skippedframes + "</span>";

            // note the double not (~) removes the decimal part more efficiently than the match.trunc fungion
            if (data.renderTotalFrames > 1000)
                document.getElementById("OBSRender").innerHTML = missedframestxt + "/" + (~~(data.renderTotalFrames / 1000)) + "k";
            else
                document.getElementById("OBSRender").innerHTML = missedframestxt + "/" + data.renderTotalFrames;
            if (data.outputTotalFrames > 1000)
                document.getElementById("OBSNetwork").innerHTML = skippedframestxt + "/" + (~~(data.outputTotalFrames / 1000)) + "k";
            else
                document.getElementById("OBSNetwork").innerHTML = skippedframestxt + "/" + data.outputTotalFrames;

            document.getElementById("OBSStrain").style["background-color"] = "rgb(" + straincolor + "," + (255 - straincolor) + ",0)";
        }
    }
    // ============================================================================
    //                           FUNCTION: UpdateOBSFilters
    // ============================================================================
    function UpdateOBSFilters ()
    {
        if (localConfig.OBSSceneslist)
        {
            let currentscene = localConfig.OBSSceneslist.current
            let element = document.getElementById("OBSFiltersRow");
            element.textContent = "";
            // need to find our scene to retrieve the filter list. who designed this structure ffs, I must have been drunk
            for (const entry in localConfig.OBSSceneslist.main) 
            {
                if (localConfig.OBSSceneslist.main[entry].sceneName === currentscene)
                {
                    if (localConfig.OBSSceneslist.main[entry].filters)
                        localConfig.OBSSceneslist.main[entry].filters.forEach((filter) =>
                            addOBSFilterButton(element, filter.filterName, localConfig.OBSSceneslist.current, filter.filterEnabled)
                        );
                    return
                }
            }
            for (const entry in localConfig.OBSSceneslist.secondary) 
            {
                if (localConfig.OBSSceneslist.secondary[entry].sceneName === currentscene)
                {
                    if (localConfig.OBSSceneslist.secondary[entry].filters)
                        localConfig.OBSSceneslist.secondary[entry].filters.forEach((filter) =>
                            addOBSFilterButton(element, filter.filterName, localConfig.OBSSceneslist.current, filter.filterEnabled)
                        );
                    return
                }
            }
            for (const entry in localConfig.OBSSceneslist.rest) 
            {
                if (localConfig.OBSSceneslist.rest[entry].sceneName === currentscene)
                {
                    if (localConfig.OBSSceneslist.rest[entry].filters)
                        localConfig.OBSSceneslist.rest[entry].filters.forEach((filter) =>
                            addOBSFilterButton(element, filter.filterName, localConfig.OBSSceneslist.current, filter.filterEnabled)
                        );
                    return
                }
            }
        }
    }
    // ============================================================================
    //                           FUNCTION: addOBSFilterButton
    // ============================================================================
    function addOBSFilterButton (element, displayname, scenename, enabled)
    {
        let button = document.createElement('input');
        button.type = 'button';
        button.value = displayname;
        if (enabled)
            button.classList = "btn btn-sm btn-success mx-1";
        else
            button.classList = "btn btn-sm btn-secondary mx-1";
        button.addEventListener('click', function ()
        {
            event.preventDefault();
            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket(
                    "ExtensionMessage",
                    serverConfig.extensionname,
                    sr_api.ExtensionPacket(
                        "action_ToggleFilter",
                        serverConfig.extensionname,
                        {
                            sourceName: scenename,//"#4x3_Cam",
                            filterName: displayname, //"mycolorCorrection",
                            filterEnabled: !enabled //false
                        },
                        "",
                        "obs"
                    ),
                    "",
                    "obs"
                )
            )
            return false;
        }, false);

        element.appendChild(button);
    }
    // ============================================================================
    //                      FUNCTION: parseExtensionModalData
    // ============================================================================
    // Desription: This function will retireve the data from the modal and 
    // send the push the data out so others can update theirs to reflect the change
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // None
    // ===========================================================================
    function parseExtensionModalData (extension, page_id)
    {
        let fieldsAsArray = $('#' + page_id).serializeArray();
        // convert our array of objects into a more usable objet
        var fieldsAsObject = fieldsAsArray.reduce((obj, item) => (obj[item.name] = item.value, obj), {});
        if (fieldsAsObject.extensionname)
            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket(
                    "ExtensionMessage",
                    serverConfig.extensionname,
                    sr_api.ExtensionPacket(
                        fieldsAsObject.modaldatatype,
                        serverConfig.extensionname,
                        fieldsAsObject,
                        "",
                        fieldsAsObject.extensionname),
                    "",
                    fieldsAsObject.extensionname
                ));

    }
    // ============================================================================
    //                      FUNCTION: UpdateOwnSettingsWidgetSmallData
    // ============================================================================
    // Desription: Update our own modal if our config has changed
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // 
    // ===========================================================================
    function UpdateOwnSettingsWidgetSmallData ()
    {
        //get our widget and use string replace to update the values
        let modalstring = livePortalData.extensions[serverConfig.extensionname].settingswidgetsmall_placeholder
        for (const [key, value] of Object.entries(serverConfig))
        {
            // checkboxes
            if (value === "on")
                modalstring = modalstring.replaceAll(' ' + key + 'checked', 'checked');
            else if (key === "randomfactstimeout")
                modalstring = modalstring.replaceAll('"' + key + 'text"', '"' + (value / 60000) + '"');
            // replace text strings
            else if (typeof (value) == "string" || typeof (value) == "number")
                modalstring = modalstring.replaceAll('"' + key + 'text', '"' + value);
        }
        livePortalData.extensions[serverConfig.extensionname].settingswidgetsmall = modalstring;
        //document.getElementById(serverConfig.extensionname + "_settingswidgetsmallmodal").innerHTML = modalstring;
        // Update the OBS channel list as we might have changed what we want to show

        addSettingsWidgetSmall(serverConfig.extensionname, modalstring)

    }
    // ============================================================================
    //                      FUNCTION: UpdateOwnSettingsWidgetLargeData
    // ============================================================================
    // Desription: Update our own modal if our config has changed
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // 
    // ===========================================================================
    function UpdateOwnSettingsWidgetLargeData ()
    {

        //get our widget and use string replace to update the values
        let modalstring = livePortalData.extensions[serverConfig.extensionname].settingswidgetlarge_placeholder
        for (const [key, value] of Object.entries(serverConfig))
        {
            // checkboxes
            if (value === "on")
                modalstring = modalstring.replaceAll(' ' + key + 'checked', 'checked');
            else if (key === "randomfactstimeout") // change random facts to seconds from milliseconds
                modalstring = modalstring.replaceAll('"' + key + 'text"', '"' + (value / 60000) + '"');
            // replace text strings
            else if (typeof (value) == "string" || typeof (value) == "number")
                modalstring = modalstring.replaceAll('"' + key + 'text', '"' + value);
        }
        livePortalData.extensions[serverConfig.extensionname].settingswidgetlarge = modalstring;
        //document.getElementById(serverConfig.extensionname + "_settingswidgetlargemodal").innerHTML = modalstring;
        // Update the OBS channel list as we might have changed what we want to show

        // re-add the widge so it is updated on screen
        addALLSettingsWidgetLarge()

    }
    // ============================================================================
    //                      FUNCTION: processOwnSettingsWidgetSmallSubmit
    // ============================================================================
    // Desription: This function will retireve the data from the modal and 
    // send save it in the serverConfig after we hit the submit button
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // None
    // ===========================================================================
    function processOwnSettingsWidgetSmallSubmit (name)
    {
        // get the modal data as an array
        let fieldsAsArray = $('#' + name + "_settingswidgetsmallmodal").serializeArray();
        // convert our array of objects into a more usable object
        var fieldsAsObject = fieldsAsArray.reduce((obj, item) => (obj[item.name] = item.value, obj), {});
        // loop though our keys and set them to match what is in the modal
        for (const [key, value] of Object.entries(serverConfig))
        {
            if (key === "randomfactstimeout")
                serverConfig[key] = fieldsAsObject[key] * 60000
            else if (value === "on" && !fieldsAsObject[key])
                serverConfig[key] = "off";
            else if (key in fieldsAsObject)
                serverConfig[key] = fieldsAsObject[key];
        }
        //save the data to the server
        SaveConfigToServer();
    }
    // ============================================================================
    //                      FUNCTION: processOwnSettingsWidgetLargeSubmit
    // ============================================================================
    // Desription: This function will retireve the data from the modal and 
    // send save it in the serverConfig after we hit the submit button
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // None
    // ===========================================================================
    function processOwnSettingsWidgetLargeSubmit (name)
    {
        // get the modal data as an array
        let fieldsAsArray = $('#' + name + "_settingsform").serializeArray();
        // convert our array of objects into a more usable object
        var fieldsAsObject = fieldsAsArray.reduce((obj, item) => (obj[item.name] = item.value, obj), {});

        // check for restore defaults being hit
        if (fieldsAsObject.liveportal_restore_defaults == "on")
        {
            serverConfig = structuredClone(default_serverConfig);
            changeServerLogging(serverConfig.logginglevel);
            changeDiscordListeningChannel(serverConfig.modmessage_channel)
            return;
        }
        else
        {
            if (fieldsAsObject.logginglevel != serverConfig.logginglevel)
            {
                // change server logging level
                changeServerLogging(fieldsAsObject.logginglevel);
                serverConfig.logginglevel = fieldsAsObject.logginglevel;
            }
            // loop though our keys and set them to match what is in the modal
            for (const [key, value] of Object.entries(serverConfig))
            {
                //lets check our settings and send out updates as required
                if (key === "modmessage_channel")
                {
                    // udpate the server (or just refresh the value even if the same)
                    serverConfig[key] = fieldsAsObject[key];
                    changeDiscordListeningChannel(serverConfig[key]);
                }
                else if (key === "randomfactstimeout")
                    serverConfig[key] = fieldsAsObject[key] * 60000
                else if (value === "on" && !fieldsAsObject[key])
                    serverConfig[key] = "off";
                else if (key in fieldsAsObject)
                    serverConfig[key] = fieldsAsObject[key];
            }
        }
        //save the data to the server
        SaveConfigToServer();
    }
    // ============================================================================
    //                           FUNCTION: changeServerLogging
    // ============================================================================
    function changeServerLogging (logsetting)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "SetLoggingLevel",
                serverConfig.extensionname,
                logsetting,
            ));
    }
    // ============================================================================
    //                           FUNCTION: displayChatMessages
    // ============================================================================
    // display buffers on screen
    function displayChatMessages ()
    {
        let chatcardref = document.getElementById("ChatMessagesCardText")
        let modcardref = document.getElementById("ModMessagesCardText")

        // limit chat buffer to the number of lines we want to use
        while (localConfig.chatMessageBuffer.length > serverConfig.chatmessagebuffermaxsize)
            localConfig.chatMessageBuffer.shift();

        // limit chat buffer to the number of lines we want to use
        while (localConfig.modMessageBuffer.length > serverConfig.modmessagebuffermaxsize)
            localConfig.modMessageBuffer.shift();

        // add the buffer into the chat window
        chatcardref.innerHTML = localConfig.chatMessageBuffer.join(" ");
        modcardref.innerHTML = localConfig.modMessageBuffer.join(" ");

        // Auto scroll the boxes unless we have a new buffer, then we scroll to the end
        if (!localConfig.newTwitchChatBuffer)
            MessageboxAutoscroll("ChatMessagesCardText")
        else
        {
            const cardref = document.getElementById("ChatMessagesCardText")
            const cardScrollHeight = cardref.scrollHeight;
            cardref.scrollTo(0, cardScrollHeight + 5);
            localConfig.newTwitchChatBuffer = false;
        }

        if (!localConfig.newDiscordChatBuffer)
            MessageboxAutoscroll("ModMessagesCardText")
        else
        {
            const cardref = document.getElementById("ModMessagesCardText")
            const cardScrollHeight = cardref.scrollHeight;
            cardref.scrollTo(0, cardScrollHeight + 5);
            localConfig.newDiscordChatBuffer = false;
        }

    }
    // ============================================================================
    //                           FUNCTION: processTwitchChatBuffer
    // ============================================================================
    // Desription: Processes a message from the data center with the previous chat buffer
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    async function processTwitchChatBuffer (chatdata)
    {
        let counter = 0
        // as we have received a bufer lets delete the old data
        document.getElementById("ChatMessagesCardText").innerHTML = "";

        localConfig.chatMessageBuffer = [];
        chatdata.forEach(ele => 
        {
            parseTwitchChatMessage(ele);
        })
        localConfig.chatMessageBuffer.push("<BR>--------- buffer loaded --------");

    }
    // ============================================================================
    //                           FUNCTION: processTwitchAccountNames
    // ============================================================================
    // Desription: Processes a message from the data center with the previous chat buffer
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    async function processTwitchAccountNames (extension_packet)
    {
        // as we have received a bufer lets delete the old data
        let newchatternames = ""
        let twitchnamedropdowns = ""
        localConfig.usernamelist = extension_packet.data;
        // if we have a username set in our config and that is in the current list of names lets use that one
        if (serverConfig.chatAsUsername && Object.values(extension_packet.data).indexOf(serverConfig.chatAsUsername) > -1)
        {
            document.getElementById("chatuserselect").innerHTML = serverConfig.chatAsUsername;
        }
        else if (extension_packet.data && extension_packet.data[0])
        {
            // if we don't have a valid username then use the first one in the list passed in
            document.getElementById("chatuserselect").innerHTML = extension_packet.data[0];
            serverConfig.chatAsUsername = extension_packet.data[0];
        }
        else
            document.getElementById("chatuserselect").innerHTML = "Select a User to chat as";

        twitchnamedropdowns = document.getElementById("chatuserchattername");
        for (const [key, value] of Object.entries(extension_packet.data)) 
        {
            newchatternames += "<li><a id='" + value + "_user_select' class='dropdown-item' href='#' value=" + value + " onClick='userDropdownChanged( this )'>" + value + "</a></li>"
        }
        twitchnamedropdowns.innerHTML = newchatternames

    }
    // ============================================================================
    //                           FUNCTION: userDropdownChanged
    // ============================================================================
    // Desription: user has changed the account in the twitch chat box
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function userDropdownChanged (e)
    {
        document.getElementById("chatuserselect").innerHTML = e.innerHTML;
        // if we have changed users update the config to remember it
        if (serverConfig.chatAsUsername != e.innerHTML)
        {
            serverConfig.chatAsUsername = e.innerHTML;
            SaveConfigToServer()
        }
    }
    // ============================================================================
    //                           FUNCTION: processDiscordChatBuffer
    // ============================================================================
    // Desription: Processes a message from the data center with the previous chat buffer
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    async function processDiscordChatBuffer (chatdata)
    {
        let counter = 0
        // as we have received a bufer lets delete the old data
        document.getElementById("ModMessagesCardText").innerHTML = "";
        localConfig.modMessageBuffer = [];

        if (chatdata)
            chatdata.forEach(ele => 
            {
                parseDiscordChatMessage(ele);
            })
        localConfig.modMessageBuffer.push("<BR>--------- buffer loaded --------");
    }
    // ============================================================================
    //                           FUNCTION: parseTwitchChatMessage
    //      this will take a chat message and parse it for colouring, 
    //      sending to chatbot etc
    // ============================================================================
    // updates the buffer with the messages
    function parseTwitchChatMessage (chatdata)
    {
        try
        {
            // Message we have currently handled, use this to develope handling of new messages yet to be seen
            // hard to test all messages as we can't generate them
            var messages_handled = ["chat", "action", "resub", "primepaidupgrade", "submysterygift", "join", "connecting", "logon", "connected",
                "twitchchat_extension", "disconnected", "reconnect", "sub", "resub", "messagedeleted", "timeout", "ban", "System", "raided", "notice", "redeem"]
            var sub_messages = ["sub", "resub", "primepaidupgrade", "submysterygift"];
            var modactions = ["messagedeleted", "timeout", "ban", "notice"]
            if (!messages_handled.includes(chatdata.data["message-type"]) && chatdata.data["display-name"] != "System" && chatdata.data["display-name"].indexOf("(localpost)") == -1)
                console.log("not handling these messages yet, still work in progress", chatdata.data)

            // setup the date field
            var today = new Date();
            var time = today.getHours() + ":" + String(today.getMinutes()).padStart(2, '0') + ":" + String(today.getSeconds()).padStart(2, '0');
            // make setup our fields for parts of the message
            var time_color = "<span style='color: " + chatcolors.default_timecode_color + "'>";
            var end_time_color = "</span>"
            var user_color = "";
            var end_user_color = "";
            var background_color = "";
            var end_background_color = "";
            var user_icons = "";
            var action = "";
            var endaction = "";
            var mod_badge = "<img src='liveportal/images/badge_mod.png'>";
            var greyout_line = "false";

            // three main parts of a message are built up into these tags
            // linefield + time_field + name_field + message_field + endline_field
            var time_field = time_color + time + ":" + end_time_color;
            var name_field = "";
            var message_field = "";
            var line_field = "<BR><span>";
            var end_line_field = "</span>";

            // lets sanitise the message before we add the emotes
            // we do this by pushing it into an html div and then pulling it out again
            // kind of a hack but it works :D
            var sanitiser = document.createElement('div');
            sanitiser.innerText = chatdata.message
            var message = sanitiser.innerHTML
            // set the window title (might have updated)
            document.getElementById("ChatMessagesCardTitle").innerHTML = "Chat: " + chatdata.channel

            //  #################################
            //   check for an action messge '/me'
            //  ################################
            if (chatdata.data["message-type"] == "action")
            {
                action = "<i>";
                endaction = "</i>"
            }
            //  ################################################################################
            //       UNHANDLED MESSAGES. NEED TO BE FORMATTED CORRECTLY
            //  ################################################################################
            if (!(messages_handled.includes(chatdata.data["message-type"])))
            {
                background_color = "<span style='color:" + chatcolors.default_TBD_text_color + "; background-color: " + chatcolors.default_TBD_background_color + "; '>";
                message = message + " <message-type>: " + ((chatdata.data["message-type"]) ? chatdata.data["message-type"] : "")
                end_background_color = "</span>"
            }

            //  ##################################
            //  check if someone @'d us
            //  ##################################
            if (localConfig.usernamelist && localConfig.usernamelist.user && chatdata.message && chatdata.message.toLowerCase().indexOf('@' + localConfig.usernamelist.user.toLowerCase()) > -1)
            {
                var myregex = new RegExp("@" + localConfig.usernamelist.user, "gi")
                message = message.replace(myregex, "<span style='color:" + chatcolors.default_text_bright_color + ";background-color: " + chatcolors.default_user_at_color + ";'> @" + localConfig.usernamelist.user + "</span>")
            }

            //  ##################################
            //      add any twitch emotes
            //  ##################################
            message = addTwitchEmotes(message, chatdata.data.emotes);

            //  ##################################
            //     Mod Actions
            //  ##################################
            if ((modactions.includes(chatdata.data["message-type"])))
            {
                user_color = mod_badge;
                line_field = "<BR><span style='color: " + chatcolors.default_mod_action + "'>"
                name_field = chatdata.data['display-name'] + "> ";
                message_field = message;
                // set the card data
                localConfig.chatMessageBuffer.push(line_field + time_field + name_field + message_field + end_line_field);
            }
            // ########################################## 
            //  Our Bot messages (ie chatbot)
            // ##########################################
            else if (localConfig.usernamelist && chatdata.data['display-name'] === localConfig.usernamelist.bot && chatdata.data["message-type"] == "chat")
            {
                user_color = mod_badge;
                line_field = "<BR><span style='color: " + chatcolors.default_greyout_color + "'>"
                name_field = chatdata.data['display-name'] + "> ";
                message_field = message;
                // set the card data
                localConfig.chatMessageBuffer.push(line_field + time_field + name_field + message_field + end_line_field);
            }

            // ##################### 
            //  system messages 
            // #####################
            else if (chatdata.data['display-name'] === "System")
            {
                // set the card data
                line_field = "<BR><span style='color: " + chatcolors.default_system_color + "'>"
                name_field = chatdata.data['display-name'] + "> ";
                message_field = message;
                localConfig.chatMessageBuffer.push(line_field + time_field + name_field + message_field + end_line_field);
                //localConfig.chatMessageBuffer.push("<BR><span style='color: " + default_system_color + "'>" + time + "::: " + chatdata.data['display-name'] + " " + message + "</span>");
            }
            // ##################### 
            //     sub messages 
            // #####################
            else if (sub_messages.includes(chatdata.data["message-type"]))
            {
                line_field = "<BR><span style='color: " + chatcolors.default_sub_color + "'>"
                name_field = "<b>" + chatdata.data['display-name'] + "> ";
                message_field = chatdata.data['system-msg'] + ((message) ? ": " + message : "") + "</b>";
                localConfig.chatMessageBuffer.push(line_field + time_field + name_field + message_field + end_line_field);
            }
            // ##################### 
            //   chat messages 
            // #####################
            else
            {
                // ######################### reward messages #########################
                if (chatdata.data["msg-id"] || chatdata.data["custom-reward-id"])
                {
                    background_color = ((chatdata.data["msg-id"]) ? chatdata.data["msg-id"] : "CustomReward:") + " <b><span style='color: " + chatcolors.default_reward_color + "; background-color: " + chatcolors.default_reward_bgcolor + "; '>";
                    end_background_color = "</span></b>"
                }
                // ##################### username colors and icons
                // if this is not a chat message (ie a sub etc) then set username color to yellow
                if (chatdata.data["message-type"] != "chat" && chatdata.data["message-type"] != "action")
                    user_color = "<span style='color: yellow'>";
                // if the user is a mod then add the mod badge
                else if (chatdata.data.mod)
                    user_color = "<img src='liveportal/images/badge_mod.png'><span style='color:" + chatdata.data.color + "'>";
                // if we don't have a user color then lets use that instead
                else if (chatdata.data.color === null)
                    user_color = "<span style='color: " + chatcolors.default_username_color + "'>";
                // use standard color if no coler is available
                else
                    user_color = "<span style='color: " + chatdata.data.color + "'>";

                name_field = user_color + chatdata.data['display-name'] + "&gt</span> ";

                // ########### create out message line
                // set the card title (may have changed since last time around)

                // if we have no nonchat or action message highlight it so we know we need to fix this
                if (chatdata.data["message-type"] == "chat" && chatdata.data["message-type"] == "action")
                    message_field = background_color + action + message + endaction + end_background_color
                //else if (chatdata.data["message-type"] == "resub")
                //    message_field = background_color + action + message + endaction + end_background_color
                else // unhandled message
                    message_field = background_color + action + message + endaction + end_background_color

                localConfig.chatMessageBuffer.push(line_field + time_field + name_field + message_field + "<" + chatdata.data["message-type"] + ">" + end_line_field);

                // add mod messages to mod card if we have this option selected in the liveportal settings page
                if (serverConfig.modchattomodwindow === "on" && chatdata.data.mod)
                    //localConfig.modMessageBuffer.push("<BR>" + time + username + " " + message);
                    localConfig.modMessageBuffer.push(line_field + time_field + name_field + message_field + "<" + chatdata.data["message-type"] + ">" + end_line_field);

            }
        }
        catch (error)
        {
            console.log("ERROR:parseTwitchChatMessage:", error)
        }
    }
    // ============================================================================
    //                           FUNCTION: parseDiscordChatMessage
    // ============================================================================
    // updates the buffer with the messages
    function parseDiscordChatMessage (chatdata)
    {
        //let chatdata = data.data;
        let today = new Date();
        let time = today.getHours() + ":" + String(today.getMinutes()).padStart(2, '0') + ":" + String(today.getSeconds()).padStart(2, '0');
        // make it colorful
        let time_color = "<span style='color: #757875'>";
        var end_time_color = "</span>";
        let user_color = "";
        // https://cdn.discordapp.com/emojis/634006521180717067
        let message = parseDiscordEmojis(chatdata.message);
        // lets sanitise the message before we add the emotes
        var sanitiser = document.createElement('div');
        if (chatdata.name === "System")
            localConfig.modMessageBuffer.push("<BR><span style='color: red'>" + time + ":" + chatdata.name + " " + message + "</span>");
        else
        {
            user_color = "<span style='color: #6f42c1'>";
            let username = user_color + ' ' + chatdata.name + "&gt</span>";
            time = time_color + time + ":" + end_time_color;

            localConfig.modMessageBuffer.push("<BR>" + time + ":" + username + " " + message);

        }
    }
    // ============================================================================
    //                           FUNCTION: addDiscordEmotes

    // ============================================================================
    function parseDiscordEmojis (message)
    {
        let index = message.indexOf('<');
        let is, ie, emoji = 0;
        let msg = message;
        let newmessage = ""
        if (msg.indexOf('<') == -1)
            return message;

        // check if we have emoji. this should really be a bit better, ie a patternmatch (in the form of <name:id>)
        while (msg.indexOf('<') > 0)
        {
            //log the start of the possible emoji
            index = msg.indexOf('<');
            // get the start of the id
            is = msg.indexOf(':', index + 2);
            // get the end of the id string
            ie = msg.indexOf('>', index)
            // get the first part of the message (up to the next emoji)
            newmessage = newmessage + msg.slice(0, index);
            // get the emoji
            emoji = msg.slice(is + 1, ie);
            // remove the message up to the emoji
            msg = msg.slice(ie + 1); // skip past the first '<:'
            // add the emoji to the message
            newmessage = newmessage + "<img src='https://cdn.discordapp.com/emojis/" + emoji + "' width='25' height='25'>";
        }
        return newmessage;
    }
    // ============================================================================
    //                           FUNCTION: addTwitchEmotes
    // ============================================================================
    function addTwitchEmotes (message, emotes)
    {
        if (!emotes) return message;

        // store all emote keywords
        // ! you have to first scan through 
        // the message string and replace later
        const stringReplacements = [];
        let theme = "light"
        if (localStorage.getItem("darkmode") === "true")
            theme = "dark"
        // iterate of emotes to access ids and positions
        Object.entries(emotes).forEach(([id, positions]) =>
        {
            // use only the first position to find out the emote key word
            const position = positions[0];
            const [start, end] = position.split("-");
            const stringToReplace = message.substring(
                parseInt(start, 10),
                parseInt(end, 10) + 1
            );
            if (stringToReplace != ":/")
                stringReplacements.push({
                    stringToReplace: stringToReplace,
                    //replacement: `<img src="https://static-cdn.jtvnw.net/emoticons/v1/${id}/1.0">`,
                    replacement: "<img src='https://static-cdn.jtvnw.net/emoticons/v2/" + id + "/default/" + theme + "/1.0'>"
                });
        });

        // generate HTML and replace all emote keywords with image elements
        const messageHTML = stringReplacements.reduce(
            (acc, { stringToReplace, replacement }) =>
            {
                // obs browser doesn't srsmm to know about replaceAll
                return acc.split(stringToReplace).join(replacement);
            },
            message
        );
        return messageHTML.replaceAll("\n", " ");;
    }

    // ============================================================================
    //                           FUNCTION:DisplayAlertMessages
    // ============================================================================
    // Desription: display alerts
    // Parameters: alert message
    // ----------------------------- notes ----------------------------------------
    // None
    // ===========================================================================
    function DisplayAlertMessages (message)
    {
        let cardref = document.getElementById("AlertCardText");
        cardref.innerHTML = cardref.innerHTML + message
        // keep scroll at the bottom of the card
        var cardScrollHeight = cardref.scrollHeight;
        cardref.scrollTo(0, cardScrollHeight + 1);
    }

    // ============================================================================
    //                           FUNCTION:MessageboxAutoscroll
    // ============================================================================
    // Desription: keeps a message box scrolled if user hasn't scrolled up
    // Parameters: e
    // ----------------------------- notes ----------------------------------------
    // None
    // ===========================================================================
    function MessageboxAutoscroll (messageBoxName)
    {
        let container = document.getElementById(messageBoxName)
        // only scroll if the mouse isn't down (user srolling) or if we are already 
        // within 40 pixels of the new mesages coming in. 
        if (!localConfig.mouseDown && ((container.scrollHeight - (container.scrollTop + container.clientHeight)) < 40))
            container.scrollTop = container.scrollHeight + 1;

    }
    // ============================================================================
    //                           FUNCTION: RequestExtList
    // ============================================================================
    // Desription: Sends a message to the data center to get the list of extensions
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function RequestExtList ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "RequestExtensionsList",
                serverConfig.extensionname,
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestOBSScenes
    // ============================================================================
    // Desription: Sends a message to the data center to get the list of extensions
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function RequestOBSScenes (to)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestScenes",
                    serverConfig.extensionname,
                ),
                "",
                to,
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestChList
    // ============================================================================
    // Desription: Sends a message to the data center to get the list of channels
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function RequestChList ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "RequestChannelsList",
                serverConfig.extensionname,
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestChatBuffer
    // ============================================================================
    // Desription: Sends a message to the data center to get the previous chat buffer
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function RequestChatBuffer (extname)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestChatBuffer",
                    serverConfig.extensionname,
                    "",
                    "",
                    extname),
                "",
                extname
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestTwitchAccountNames
    // ============================================================================
    // Desription: Get our usernames from the twitch extension (so we can post as them)
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function RequestTwitchAccountNames (extname)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestAccountNames",
                    serverConfig.extensionname,
                    "",
                    "",
                    extname),
                "",
                extname
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestSettingsWidgetSmallsCode
    // ============================================================================
    // Desription: Sends a message to the extension to gets its html code
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function RequestSettingsWidgetSmallsCode (extname)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestSettingsWidgetSmallCode",
                    serverConfig.extensionname,
                    "",
                    "",
                    extname),
                "",
                extname
            ));
    }

    // ============================================================================
    //                           FUNCTION: RequestSettingsWidgetLargeCode
    // ============================================================================
    // Desription: Sends a message to the extension to gets its html code
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function RequestSettingsWidgetLargeCode (extname)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestSettingsWidgetLargeCode",
                    serverConfig.extensionname,
                    "",
                    "",
                    extname),
                "",
                extname
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestLoggingLevel
    // ============================================================================
    function RequestLoggingLevel ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "RequestLoggingLevel",
                serverConfig.extensionname,
            ));
    }
    // ============================================================================
    //                           FUNCTION: ProcessStreamlabsAlert
    // ============================================================================
    function ProcessStreamlabsAlert (extension_packet)
    {
        let alertdata = extension_packet.data;
        // display the alert

        let messagetxt = "Thankyou ";
        let alerttext = "";
        switch (alertdata.messagetype)
        {
            case "trigger_TwitchFollowReceived":
                messagetxt += alertdata.parameters.username + " for the follow."
                if (serverConfig.follows === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-secondary'>TwitchFollow: " + alertdata.parameters.username + "</div>";
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_TwitchRaidReceived":
                messagetxt += alertdata.parameters.username + " for the raid " + alertdata.parameters.raiders + " raiders."
                if (serverConfig.raids === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-success'>TwitchRaid: " + alertdata.parameters.username + " " + alertdata.parameters.raiders + "</div>";
                DisplayAlertMessages(alerttext);
                postMessageToTwitch("!so " + alertdata.parameters.username)
                break;
            case "trigger_TwitchHostReceived":
                messagetxt += alertdata.parameters.username + " for the host with " + alertdata.parameters.viewers + " viewers."
                if (serverConfig.hosts === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-success'>TwitchHost: " + alertdata.parameters.username + " " + alertdata.parameters.viewers + "</div>";
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_StreamlabsDonationReceived":
                if (alertdata.parameters.message === null)
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.formatted_amount + ' donation and helping keep the stream alive.'
                else
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.formatted_amount + ' donation and helping keep the stream alive. "' + alertdata.parameters.message + '"'
                if (serverConfig.donations === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                postMessageToTwitch(messagetxt, "user")
                alerttext = "<div class='text-danger'>SLDonation: " + alertdata.parameters.username + "  " + alertdata.parameters.formatted_amount + ' "' + alertdata.parameters.message + '"</div>';
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_TwitchCharityDonationReceived":
                if (alertdata.parameters.message === null)
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.formatted_amount + ' donation to charity, you are an awesome human being.'
                else
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.formatted_amount + ' donation to charity, you are an awesome human being. "' + alertdata.parameters.message + '"'
                if (serverConfig.donations === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                postMessageToTwitch(messagetxt, "user")
                alerttext = "<div class='text-danger'>Twitch Charity Donation: " + alertdata.parameters.username + "  " + alertdata.parameters.formatted_amount + ' "' + alertdata.parameters.message + '"</div>';
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_TwitchBitsReceived":
                if (alertdata.parameters.message === null)
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.amount + ' bits.'
                else
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.amount + ' bits. "' + alertdata.parameters.message + '"'
                if (serverConfig.bits === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-danger'>TwitchBits: " + alertdata.parameters.username + " " + alertdata.parameters.amount + ' bits. "' + alertdata.parameters.message + '"</div>';
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_TwitchSubscriptionReceived":
                if (alertdata.parameters.type === "subgift" && alertdata.parameters.gifter != null)
                {
                    messagetxt += alertdata.parameters.username + " was gifted a sub from " + alertdata.parameters.gifter
                    if (serverConfig.subs === "on")
                        PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                    alerttext = "<div class='text-secondary'TwitchSubGift" + alertdata.parameters.username + '</div>';
                    DisplayAlertMessages(alerttext);
                }
                else
                {
                    let submessage = alertdata.parameters.message;
                    if (submessage === null)
                        submessage = ""
                    if (alertdata.parameters.months === 1)
                        messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.months + ' month subscription. "' + submessage + '"'
                    else
                        messagetxt += alertdata.parameters.username + " for " + alertdata.parameters.months + ' months of subscriptions. "' + submessage + '"'
                    if (serverConfig.subs === "on")
                        PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                    alerttext = "<div class='text-primary'>TwitchSubscription: " + alertdata.parameters.username + " " + alertdata.parameters.months + 'm "' + submessage + '"</div>';
                    DisplayAlertMessages(alerttext);
                }
                break;
            case "trigger_TwitchResubReceived":
                if (alertdata.parameters.message === null)
                    messagetxt += alertdata.parameters.username + " for " + alertdata.parameters.months + ' months of subcriptions (with a streak of ' + alertdata.parameters.streak_months + ').'
                else
                    messagetxt += alertdata.parameters.username + " for " + alertdata.parameters.months + ' months of subcriptions (with a streak of ' + alertdata.parameters.streak_months + '). "' + alertdata.parameters.message + '"'
                if (serverConfig.resubs === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-primary'>TwitchResub: " + alertdata.parameters.username + " " + alertdata.parameters.months + 'm (' + alertdata.parameters.streak_months + ' streak). "' + alertdata.parameters.message + '"</div>';
                DisplayAlertMessages(alerttext);
                break;

            case "trigger_TwitchTwitchSubMysteryGiftReceived":
                messagetxt += alertdata.parameters.gifter + " for the " + alertdata.parameters.amount + " gifted subs"
                //postMessageToTwitch(messagetxt)
                if (serverConfig.giftsubs === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-danger'>TwitchGiftSub: " + alertdata.parameters.gifter + " gifted " + alertdata.parameters.amount + " subs</div>"
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_MerchPurchaseReceived"://trigger
                messagetxt += alertdata.parameters.username + " purchacing my merch. Hope you enjoy the " + alertdata.parameters.product + ". " + alertdata.parameters.imageHref
                if (serverConfig.merch === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                postMessageToTwitch(messagetxt, "user")
                alerttext = "<div class='text-secondary'>SLMerch: " + alertdata.parameters.username + "  " + alertdata.parameters.product + "</div>"
                DisplayAlertMessages(alerttext);
                break;
            case "LoyaltyStoreRedemptionReceived"://trigger
                messagetxt += alertdata.parameters.username + " for using the your channel points for " + alertdata.parameters.product + ". " + alertdata.parameters.imageHref
                if (serverConfig.cloudbotredemption === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                postMessageToTwitch(messagetxt, "user")
                alerttext = "<div class='text-secondary'>SLLoyalty: " + alertdata.parameters.username + " " + alertdata.parameters.product + "</div>"
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_YouTubeSubscriptionReceived":
                messagetxt += alertdata.parameters.username + " for the Subscription."
                if (serverConfig.follows === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-secondary'>YouTubeSubscription: " + alertdata.parameters.username + "</div>";
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_YouTubeMemberReceived":
                messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.months + " Membership."
                if (serverConfig.follows === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-secondary'>YouTubeMembership: " + alertdata.parameters.username + " " + alertdata.parameters.months + "months</div>";
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_YouTubeSuperchatReceived":
                if (alertdata.parameters.message === null)
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.formatted_amount + ' superchat, you are an awesome human being.'
                else
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.formatted_amount + ' superchat, you are an awesome human being. "' + alertdata.parameters.message + '"'
                if (serverConfig.donations === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                postMessageToTwitch(messagetxt, "user")
                alerttext = "<div class='text-danger'>YouTubeSuperChat: " + alertdata.parameters.username + "  " + alertdata.parameters.formatted_amount + ' "' + alertdata.parameters.message + '"</div>';
                DisplayAlertMessages(alerttext);
                break;
        }
    }
    // ============================================================================
    //                           FUNCTION: PostMessageToDiscord
    // ============================================================================
    function PostMessageToDiscord (msg, channel)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "PostMessage",
                    serverConfig.extensionname,
                    {
                        message: msg,
                        channel: channel
                    },
                    "",
                    "discordchat"),
                "",
                "discordchat"
            ));
    }
    // ============================================================================
    //                           FUNCTION: postMessageToTwitter
    // ============================================================================
    function postMessageToTwitter (msg1, msg2)
    {

        msg1 += " ";
        msg2 += " ";
        let msg_end = "Sent from StreamRoller";
        let msg_fact = "";
        if (serverConfig.randomfactstwitterstartenabled == "on" && localConfig.randomFact !== "")
            msg_fact = "FOTD:" + localConfig.randomFact + " ";

        // we have enough space for everything 
        if (((msg1.length - 12) + msg2.length + msg_fact.length + msg_end.length) < 281)
            msg1 = msg1 + msg2 + msg_fact + msg_end;
        //we have enough space if we remove the extra message
        else if (((msg1.length - 12) + msg_fact.length + msg_end.length) < 281)
            msg1 = msg1 + msg_fact + msg_end;
        //we can't fit random fact and main message in so remove the random fact
        else if (((msg1.length - 12) + msg2.length + msg_end.length) < 281)
            msg1 = msg1 + msg2 + msg_end;
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "action_PostTweet",
                    serverConfig.extensionname,
                    { message: msg1 },
                    "",
                    "twitter"),
                "",
                "twitter"
            ));
        // get a new random fact
        RequestRandomFact();
    }
    // ============================================================================
    //                           FUNCTION: postMessageToTwitch
    // ============================================================================
    function postMessageToTwitch (msg, account = "bot")
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "action_SendChatMessage",
                    serverConfig.extensionname,
                    // need to read accounts from twitchchat ext and give an option to chose who to send the message as
                    {
                        account: account,
                        message: msg,
                        'message-type': "chat"
                    },
                    "",
                    "twitchchat"),
                "",
                "twitchchat"
            ));
    }
    // ============================================================================
    //                           FUNCTION: changeDiscordListeningChannel
    // ============================================================================
    function changeDiscordListeningChannel (channel)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "ChangeListeningChannel",
                    serverConfig.extensionname,
                    channel,
                    "",
                    "discordchat"),
                "",
                "discordchat"
            ));
    }
    // ============================================================================
    //                           FUNCTION: chatInput
    // ============================================================================
    function chatInput (event)
    {
        event.preventDefault();
        postMessageToTwitch(document.getElementById("chatInputText").value, serverConfig.chatAsUsername)
        document.getElementById("chatInputText").value = ""
    }
    // ============================================================================
    //                           FUNCTION: modInput
    // ============================================================================
    function modInput (event)
    {
        event.preventDefault();
        PostMessageToDiscord(document.getElementById("modInputText").value, serverConfig.modmessage_channel);
        document.getElementById("modInputText").value = ""
    }
    // ============================================================================
    //                           FUNCTION: RequestSongLists
    // ============================================================================
    function RequestSongLists ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestSonglist",
                    serverConfig.extensionname,
                    "",
                    "",
                    "streamersonglist"),
                "",
                "streamersonglist"
            ));
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestQueue",
                    serverConfig.extensionname,
                    "",
                    "",
                    "streamersonglist"),
                "",
                "streamersonglist"
            ));
    }

    // ============================================================================
    //                           FUNCTION: RquestPhilipsHueData
    // ============================================================================
    function RquestPhilipsHueData ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "GetAllScenes",
                    serverConfig.extensionname,
                    "",
                    "",
                    "philipshue"),
                "",
                "philipshue"
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestRandomFact
    // ============================================================================
    function RequestRandomFact ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "action_RequestRandomFact",
                    serverConfig.extensionname,
                    "",
                    {},
                    "randomfact"),
                "",
                "randomfact"
            ));
    }
    // ============================================================================
    //                           FUNCTION: processRandomFact
    // ============================================================================
    function processRandomFact (data)
    {
        localConfig.randomFact = data;
    }
    // ============================================================================
    //                           FUNCTION: processTimers
    // ============================================================================
    function processTimers (data)
    {
        localConfig.timers[data.name] = data.timeout
    }

    // ============================================================================
    //                           FUNCTION: twitchFactOfTheDay
    // ============================================================================
    function twitchFactOfTheDay ()
    {
        if (localConfig.twitchRandomFactHandle != null)
            clearTimeout(localConfig.twitchRandomFactHandle);

        localConfig.twitchRandomFactHandle = setTimeout(function ()
        {
            if (localConfig.randomFact != "")
                postMessageToTwitch("Random Fact: " + localConfig.randomFact, "bot")
            RequestRandomFact();
            twitchFactOfTheDay();

        },
            serverConfig.randomfactstimeout
        )

    }
    // ============================================================================
    //                           FUNCTION: addSongToStreamersonglistQueue
    // ============================================================================
    function addSongToStreamersonglistQueue (songId)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "action_AddSongToQueue",
                    serverConfig.extensionname,
                    songId,
                    "",
                    "streamersonglist"),
                "",
                "streamersonglist"
            ));
    }
    // ============================================================================
    //                           FUNCTION: removeSongFromQueue
    // ============================================================================
    function removeSongFromQueue (queueId)
    {
        let classes = "bg-light text-dark"
        if (modeDark)
            classes = "bg-dark text-light"
        $("#queue_" + queueId + "_remove").addClass("btn-warning").removeClass(classes)
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RemoveSongFromQueue",
                    serverConfig.extensionname,
                    queueId,
                    "",
                    "streamersonglist"),
                "",
                "streamersonglist"
            ));
    }
    // ============================================================================
    //                           FUNCTION: markSongAsPlayed
    // ============================================================================
    function markSongAsPlayed (queueId)
    {
        let classes = "bg-light text-dark"
        if (modeDark)
            classes = "bg-dark text-light"
        $("#queue_" + queueId + "_played").addClass("btn-warning").removeClass(classes)
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "action_MarkSongAsPlayed",
                    serverConfig.extensionname,
                    queueId,
                    "",
                    "streamersonglist"),
                "",
                "streamersonglist"
            ));
    }
    // ============================================================================
    //                           FUNCTION: updateSingerSonglistQueue
    // ============================================================================
    function updateSingerSonglistQueue (queue)
    {
        const tabletitle = document.getElementById("streamersonglisttitle");
        const queueTableBody = document.querySelector('#queueTableBody');
        queueTableBody.innerHTML = '';
        let tableentry = "";
        let song = "";
        let songtime = "";
        let displaytime = "";
        let classes = "bg-light text-dark";
        if (modeDark == "true")
            classes = "bg-dark text-light"

        // if we havent been passed an array just use the stored one (might just be a refresh)
        if (queue != [] && queue !== undefined)
            localConfig.setreamersonglist.queue = queue;

        tabletitle.innerHTML = "Song Queue (played today: " + localConfig.setreamersonglist.queue.status.songsPlayedToday
            + ", in Queue: " + localConfig.setreamersonglist.queue.list.length + ")"
        localConfig.setreamersonglist.queue.list.forEach((entry) =>
        {
            if (song != null)
            {
                song = entry.song
                songtime = (new Date(entry.createdAt))
                displaytime = songtime.getHours() + ":" + songtime.getMinutes().toString().padStart(2, '0')

                tableentry += "<tr class = '" + classes + "'>"
                tableentry += "<td>" + displaytime + "</td>";
                tableentry += "<td>" + song.title + "</td>";
                tableentry += "<td>" + song.artist + "</td>";
                tableentry += "<td>" + (song.capo ? song.capo : "None") + "</td>";
                // number of entries in the queue
                tableentry += "<td>" + localConfig.setreamersonglist.queue.list.filter((v) => (v.songId === entry.songId)).length + "</td>";
                tableentry += "<td>" + entry.requests[0].name + "</td>";
                tableentry += "<td>" + entry.requests[0].inChat + "</td>";//inchat
                tableentry += "<td " + (entry.donationAmount > 0 ? "style = 'background: rgb(208 0 255)'" : "") + ">" + entry.donationAmount + "</td>";//$

                // mark as played button
                tableentry += "<td><button id='queue_" + entry.id + "_played'class='btn " + classes + "' style='border:1px solid rgb(174, 255, 0)' onclick='markSongAsPlayed(" + entry.id + ")'>Played</button>";
                // delete button
                tableentry += "<button id='queue_" + entry.id + "_remove' class='btn " + classes + "' style='border:1px solid rgb(174, 50, 0)' onclick='removeSongFromQueue(" + entry.id + ")'>Remove</button>"
                tableentry += "</td>";
                tableentry += "</tr>"
            }
            else
            {
                //console.log("Empty list song")
            }
        });

        queueTableBody.innerHTML = tableentry;
    }
    // ============================================================================
    //                           FUNCTION: updateSingerSonglistList
    // ============================================================================
    function updateSingerSonglistList (songlist)
    {
        localConfig.setreamersonglist.songlist = songlist;
    }
    // ============================================================================
    //                Songlist Autocomplete listener function
    // ============================================================================
    document.addEventListener("DOMContentLoaded", () => 
    {
        //add handler for when user types something
        $('#autocomplete-input').on('input', function ()
        {
            var input = $(this).val().toLowerCase();
            var autocompleteList = $('#autocomplete-list');
            // how many items to show in list
            var numbertodisplay = 5;
            autocompleteList.empty();

            if (input.length === 0)
                return;

            localConfig.setreamersonglist.songlist.some(function (item)
            {
                var itemLowerCase = item.title.toLowerCase();
                if (itemLowerCase.indexOf(input) !== -1)
                {
                    var listItem = $('<a id="songlistsearch" href="#songlistsearch" class="list-group-item list-group-item-action"></a>');
                    listItem.text(item.title);
                    listItem.on('click', function ()
                    {
                        $('#autocomplete-input').val("");
                        addSongToStreamersonglistQueue(item.id)
                        autocompleteList.empty();
                    });

                    autocompleteList.append(listItem);
                    numbertodisplay--;
                    if (numbertodisplay < 1)
                        return true

                }
            });
        });
    });
    // ============================================================================
    //                           FUNCTION: heartBeat
    // ============================================================================
    function heartBeatCallback ()
    {
        if (DataCenterSocket.connected)
        {
            document.getElementById('shutdownbutton').classList.add("btn-success");
            document.getElementById('shutdownbutton').classList.remove("btn-danger");
            document.getElementById('shutdownbutton').style.color = "green";
            document.getElementById('shutdownbuttonsvg').style.fill = "green"
        }
        else
        {
            document.getElementById('shutdownbutton').classList.add("btn-danger");
            document.getElementById('shutdownbutton').classList.remove("btn-success");
            document.getElementById('shutdownbutton').style.color = "red"
            document.getElementById('shutdownbuttonsvg').style.fill = "red"
        }
        localConfig.heartBeatHandle = setTimeout(heartBeatCallback, localConfig.heartBeatTimeout)
    }
    // ============================================================================
    //                           FUNCTION: Power Button
    // ============================================================================
    const powerbutton = document.getElementById('shutdownbutton_menu')
    powerbutton.addEventListener('click', function (e)
    {
        e.preventDefault(); // cancel the link behaviour
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(e.target.text,
                serverConfig.extensionname,
                e.target.text,
                "",
                ""
            ));
    });

    // ============================================================================
    //                           FUNCTION: setCardsVisibility
    // ============================================================================
    function setCardsVisibility ()
    {
        let card = document.getElementById("StreamerSongListCard");
        (serverConfig.streamersonglistdisplay == "on") ? (card.style.display = "block") : (card.style.display = "none");

        card = document.getElementById("ModMessagesCard");
        (serverConfig.discordmodchatdisplay == "on") ? (card.style.display = "block") : (card.style.display = "none");

        card = document.getElementById("OBSControllsCard");
        (serverConfig.obsdisplay == "on") ? (card.style.display = "block") : (card.style.display = "none");

        card = document.getElementById("PhilipsHueCard");
        (serverConfig.philipshuedisplay == "on") ? (card.style.display = "block") : (card.style.display = "none");

        card = document.getElementById("AlertsCard");
        (serverConfig.slalertsdisplay == "on") ? (card.style.display = "block") : (card.style.display = "none");

    }

    // ============================================================================
    //                           FUNCTION: sendMessageToChatbot
    //  personality_id is either 
    // num:     the id of the personality profile (starting from 0)
    // "" :     for no profile
    // default: for the currently set profiles
    // ============================================================================
    function sendMessageToChatbot (message, ident = "", personality_id = "default", model = "")
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "ParseTextMessage",
                    serverConfig.extensionname,
                    {
                        from: serverConfig.extensionname,
                        ident: ident,
                        message: message,
                        personality_id: personality_id,
                        model: model
                    },
                    "",
                    "chatbot"),
                "",
                "chatbot"
            ));
    }
    // ============================================================================
    //                           FUNCTION: processPhilipsHueScenes
    // ============================================================================
    function processPhilipsHueScenes ()
    {
        updatePhilipsHueDisplay()
    }
    // ============================================================================
    //                           FUNCTION: activatePhilipsHueScene
    // ============================================================================
    function activatePhilipsHueScene (sceneId)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "action_ActivateScene",
                    serverConfig.extensionname,
                    {
                        sceneID: sceneId
                    },
                    "",
                    "philipshue"),
                "",
                "philipshue"
            ));
    }
    // ============================================================================
    //                           FUNCTION: updatePhilipsHueDisplay
    // ============================================================================
    function updatePhilipsHueDisplay ()
    {
        // let card = document.getElementById("PhilipsHueCard");
        let scenesrow = document.getElementById("PhilipsHueScenesRow");
        let rowdata = ""
        let btnstate = "btn-outline-secondary";
        // need to update this to show the current active scene when we know what kind of data we are getting
        let first = true

        if (localConfig.philipsHueSceneList && localConfig.philipsHueSceneList.length > 0)
        {
            localConfig.philipsHueSceneList.forEach((element) =>
            {
                if (first)
                {
                    btnstate = "btn-outline-success";
                    first = false
                }
                else
                    btnstate = "btn-outline-secondary"
                rowdata += '<div id="PhilipsHueScene_' + element.id + '" class="col-1 btn ' + btnstate + ' mx-1 my-1" role="button" data-toggle="tooltip" onclick="activatePhilipsHueScene(\'' + element.id + '\')" title="Scene Name">' + element.name + '</div>';
            })
        }
        else
            rowdata += '<div id="PhilipsHueScene_no_scense_available" class="col-1 btn ' + btnstate + ' mx-1 my-1" role="button" data-toggle="tooltip" title="Scene Name">No Scenes availabe</div>';
        document.getElementById("PhilipsHueScenesRow").innerHTML = rowdata;
    }
</script>