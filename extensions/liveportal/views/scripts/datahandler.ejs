<script src="/streamroller-message-api.cjs"></script>
<%- include('../modals/extensionsettingsplaceholdermodal'); %>
    <%- include("../modals/liveportalmodalplaceholder.html"); %>
        <script>
            const serverConfig = {
                // extensions vars
                extensionname: "liveportal",
                channel: "LIVE_PORTAL",
                logginglevel: 0,

                // extensions to display on main page
                streamersonglistdisplay: "on",
                discordmodchatdisplay: "on",
                // obs settings
                obsdefaultstartscenename: "##Starting Soon",
                obsdefaultlivescenename: "##Game",
                obsdefaultintermissionscenename: "##Intermission",
                obsdefaultendscenename: "##StreamEnd",
                showprimaryscenes: "off",
                showsecondaryscenes: "off",
                showallscenes: "on",
                mutescene: "",
                muted: false,
                // chat window settings
                modchattomodwindow: "on",
                // discord settings
                modmessage_channel: "stream-mod-messages", // discord channel
                donations_channel: "announcements", // discord channel
                // alerts posting to discord
                follows: "off",
                raids: "off",
                hosts: "off",
                subs: "off",
                resubs: "off",
                giftsubs: "off",
                cloudbotredemption: "off",
                merch: "off",
                bits: "off",
                donations: "off",
                chatAsUsername: "user",

                // random facts / twitter settings
                randomfactsenabled: "off",
                randomfactstimeout: 1800000,//30 min

                randomfactstwitterstartenabled: "on",
                twitterstartenabled: "off",
                twitterstartmessage: "We're live twitch.tv/OldDepressedGamer",
                twitterstartmessage_x: "Come say Hi!",
                // max display size to maintain
                chatmessagebuffermaxsize: 300,
                discordmessagebuffermaxsize: 300,

            };
            const localConfig =
            {
                OBSSceneslist: {},
                obslive: false, // set on a heartbeat from obs messages
                heartBeatTimeout: "6000",
                currentchatchannel: "",
                chatMessageBuffer: [],
                modMessageBuffer: [],
                mouseDown: 0,
                randomFact: "",
                twitchRandomFactHandle: null,
                timers: [],
                newTwitchChatBuffer: false,
                newDiscordChatBuffer: false,
                // streamersonglist variables
                setreamersonglist: { songlist: [], queue: [] }
            }

            // DEBUGGING - Set this to true if you need your server data to be refreshed from above.
            // during development you may find your server data gets messed up if changing it often.
            // while uncommented your data will not presist and be overwritten by the above config
            // every time the server runs up.

            const OverwriteDataCenterConfig = false;

            // will hold the data center socket needed to send receive data
            // after refactoring the code this should hopefully not be needed anymore
            let DataCenterSocket = null;


            // truncates long log messages for easier reading. 
            const LOGGING_MAX_MESSAGE_LENGTH = 200

            // This is used to refresh the page on a new extension list
            // Currently if a second list comes in the submit handlers for the forms get broken
            // and any form submitted will cause an error.
            // possibly fixed. remove later if no issues are found
            let bugfix_extensionlist_count = -100;

            //global data store for the app
            const adminData = {};
            adminData.extensions = {};
            // add our own card

            adminData.channellist = {};
            var host = '<%= host %>';
            var port = '<%= port %>';
            localConfig.heartBeatTimeout = parseInt('<%= heartbeat %>') + 1000;
            // check for mousedown as we might need to stop the chat scroll when the user is trying to scroll the box
            document.body.onmousedown = function () { localConfig.mouseDown = true }
            document.body.onmouseup = function () { localConfig.mouseDown = false }

            ConnectToDataCenter(host, port)
            // ============================================================================
            //                           FUNCTION: ConnectToDataCenter
            // ============================================================================
            // Desription: Connect to the data center socket
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            function ConnectToDataCenter (host, port)
            {
                try
                {
                    DataCenterSocket = sr_api.setupConnection(onDataCenterMessage, onDataCenterConnect, onDataCenterDisconnect,
                        host, port);
                } catch (err)
                {
                    console.log("datahandler.initialise", "DataCenterSocket connection failed:", err);
                }
            }
            // ============================================================================
            //                           FUNCTION: onDataCenterDisconnect
            // ============================================================================
            // Desription: Received disconnect message
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            function onDataCenterDisconnect (reason)
            {
                adminData.extensions = {};
                adminData.channellist = {};
            }
            // ============================================================================
            //                           FUNCTION: onDataCenterConnect
            // ============================================================================
            // Desription: Received connect message
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            function onDataCenterConnect (socket)
            {
                // we set this hear as it means the page has loaded at this point 
                adminData.extensions[serverConfig.extensionname] = { admincard: document.getElementById('liveportalmodalplaceholder').innerHTML };

                // DEBUGGING overwrite our config data on the server if the flag is set
                if (OverwriteDataCenterConfig)
                    SaveConfigToServer();
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket(
                        "RequestConfig",
                        serverConfig.extensionname
                    ));

                //register our channels
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket(
                        "CreateChannel",
                        serverConfig.extensionname,
                        serverConfig.channel
                    ));

                //request software version
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket(
                        "RequestSoftwareVersion",
                        serverConfig.extensionname,
                        serverConfig.channel
                    ));

                //Request lists once up and running, we delay a while so other extensions can load
                setTimeout(() =>
                {
                    RequestChList();
                    RequestExtList();
                    RequestRandomFact();
                    RequestLoggingLevel();
                    RequestTwitchAccountNames("twitchchat");
                    RequestChatBuffer("twitchchat");
                    RequestChatBuffer("discordchat");
                    // setup timeout for facts on stream
                    if (serverConfig.randomfactsenabled === "on" && serverConfig.randomfactstimeout > 0)
                        twitchFactOfTheDay();

                }, 2000);


            }
            // ============================================================================
            //                           FUNCTION: onDataCenterMessage
            // ============================================================================
            // Desription: Received message
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            function onDataCenterMessage (server_packet)
            {
                // -------------------------------------------------------------------------------------------------
                //                  RECEIVED CONFIG
                // -------------------------------------------------------------------------------------------------
                if (server_packet.type === "ConfigFile")
                {
                    // update our config
                    if (server_packet.data != "")
                        // check it is our config
                        if (server_packet.to === serverConfig.extensionname)
                        {
                            for (const [key, value] of Object.entries(serverConfig))
                                if (key in server_packet.data)
                                    serverConfig[key] = server_packet.data[key];
                            setCardsVisibility();
                            // update our modal to match the new data
                            UpdateAdminModalData();
                            // update server log, mainly here if we have added new default options when a user
                            // updates their version of streamroller
                            SaveConfigToServer();
                        }
                }
                // -------------------------------------------------------------------------------------------------
                //                  RECEIVED CHANNEL LIST
                // -------------------------------------------------------------------------------------------------
                else if (server_packet.type === "ChannelList")
                {
                    adminData.channellist = server_packet.data;
                    adminData.channellist.forEach(element =>
                    {
                        if (element != serverConfig.channel)
                            sr_api.sendMessage(DataCenterSocket,
                                sr_api.ServerPacket(
                                    "JoinChannel",
                                    serverConfig.extensionname,
                                    element
                                ));
                    });
                }
                // -------------------------------------------------------------------------------------------------
                //                  RECEIVED LOGGING LEVEL
                // -------------------------------------------------------------------------------------------------
                else if (server_packet.type === "LoggingLevel")
                {
                    serverConfig.logginglevel = server_packet.data
                    UpdateAdminModalData();
                    //send modal to everyone to update their own copies of out model
                    SendModal("");
                }
                // -------------------------------------------------------------------------------------------------
                //                  RECEIVED LOGGING LEVEL
                // -------------------------------------------------------------------------------------------------
                else if (server_packet.type === "SoftwareVersion")
                {
                    document.getElementById("softwareversion").innerHTML = server_packet.data;

                }
                // -------------------------------------------------------------------------------------------------
                //                   RECEIVED EXTENSION LIST
                // -------------------------------------------------------------------------------------------------
                else if (server_packet.type === "ExtensionList")
                {
                    // we need to reload the page if we receive more than one list due to callback handler isses
                    // on the form
                    if (bugfix_extensionlist_count > 0)
                        location.reload();
                    else
                        bugfix_extensionlist_count++;
                    //load extension cards
                    loadExtensionCards(server_packet.data);
                    if (server_packet.data.includes("obs"))
                    {
                        RequestOBSScenes("obs");
                    }
                }
                else if (server_packet.type === "ExtensionMessage")
                {
                    let extension_packet = server_packet.data;
                    // -------------------------------------------------------------------------------------------------
                    //                   RECEIVED ADMIN MODAL REQUEST
                    // -------------------------------------------------------------------------------------------------
                    if (extension_packet.type === "RequestAdminModalCode")
                    {
                        SendModal(extension_packet.from);
                    }
                    // -------------------------------------------------------------------------------------------------
                    //                   RECEIVED EXTENSION MODAL CODE
                    // -------------------------------------------------------------------------------------------------
                    else if (extension_packet.type === "AdminModalCode")
                    {
                        // we process our own submits so don't do anything with the updates we send out if they come 
                        // back to us
                        if (extension_packet.from != serverConfig.extensionname)
                            addModal(extension_packet.from, extension_packet.data);
                    }
                    // -------------------------------------------------------------------------------------------------
                    //                   RECEIVED MODAL DATA (someone hit submit on a dialog)
                    // -------------------------------------------------------------------------------------------------
                    else if (extension_packet.type === "AdminModalData")
                    {
                        // check that it is not from us as we process our own code internally
                        if (extension_packet.from != serverConfig.extensionname)
                        {
                            // lets reset our config checkbox settings (modal will omit ones not
                            // checked in checkboxes so set them to "off" here first if you have them)
                            // set our config values to the ones in message
                            //for (const [key, value] of Object.entries(extension_packet.data))
                            //        serverConfig[key] = value;
                            for (const [key, value] of Object.entries(serverConfig))
                            {
                                //lets check our settings and send out updates as required
                                if (value === "on" && !extension_packet.data[key])
                                    serverConfig[key] = "off";
                                else if (key === "randomfactstimeout")
                                    serverConfig[key] = extension_packet.data[key] * 60000
                                else if (key in extension_packet.data)
                                    serverConfig[key] = extension_packet.data[key];
                            }

                            changeServerLogging(serverConfig.logginglevel)
                            // save our data to the server for next time we run
                            SaveConfigToServer();
                            //lets update our modal
                            UpdateAdminModalData();
                            // update anyone that may have out modal
                            SendModal("");
                            // setup timeout for facts on stream
                            if (serverConfig.randomFactsEnabled === "on" && serverConfig.randomFactsTimeout > 0)
                                twitchFactOfTheDay();

                        }
                    }
                    // -------------------------------------------------------------------------------------------------
                    //                   RECEIVED Scenes list from OBS
                    // -------------------------------------------------------------------------------------------------
                    else if (extension_packet.type === "SceneList")
                    {
                        ParseOBSScenesList(extension_packet.data)
                    }
                    // -------------------------------------------------------------------------------------------------
                    //                   RECEIVED Twitch chat buffer
                    // -------------------------------------------------------------------------------------------------
                    else if (extension_packet.type === "TwitchChatBuffer")
                    {
                        localConfig.newTwitchChatBuffer = true
                        // recreate our buffer
                        processTwitchChatBuffer(extension_packet.data)
                            .then(() =>
                                // display the chat buffer
                                displayChatMessages()

                            )
                    }
                    // -------------------------------------------------------------------------------------------------
                    //                   RECEIVED Twitch chat buffer
                    // -------------------------------------------------------------------------------------------------
                    else if (extension_packet.type === "UserAccountNames")
                    {
                        processTwitchAccountNames(extension_packet)
                    }
                    // -------------------------------------------------------------------------------------------------
                    //                   RECEIVED Discord chat buffer
                    // -------------------------------------------------------------------------------------------------
                    else if (extension_packet.type === "DiscordChatBuffer")
                    {
                        localConfig.newDiscordChatBuffer = true
                        // recreate our buffer
                        processDiscordChatBuffer(extension_packet.data)
                            .then(() =>
                                // display the chat buffer
                                displayChatMessages()

                            )
                    }
                    // -------------------------------------------------------------------------------------------------
                    //                   RECEIVED Discord chat buffer
                    // -------------------------------------------------------------------------------------------------
                    else if (extension_packet.type === "RandomFact")
                    {
                        processRandomFact(extension_packet.data);
                    }
                    // -------------------------------------------------------------------------------------------------
                    //                   RECEIVED Unhandled extension message
                    // -------------------------------------------------------------------------------------------------
                    else
                        console.log(".onDataCenterMessage", "ExtensionMessage not handled ", extension_packet.type, " from ", extension_packet.from);
                }
                // -------------------------------------------------------------------------------------------------
                //                   RECEIVED CHANNEL DATA
                // -------------------------------------------------------------------------------------------------
                else if (server_packet.type === "ChannelData")
                {
                    // -------------------------------------------------------------------------------------------------
                    //                           HEATBEAT
                    // -------------------------------------------------------------------------------------------------
                    let extension_packet = server_packet.data;
                    if (extension_packet.type === "HeartBeat")
                    {
                        //check if we have this extension
                        if (typeof (adminData.extensions[extension_packet.from]) !== "undefined")
                        {
                            //clear the previous timeout handle
                            clearTimeout(adminData.extensions[extension_packet.from].heartBeatHandle);
                            // setup a new timeout for this extension
                            adminData.extensions[extension_packet.from].heartBeatHandle = setTimeout(() => 
                            {
                                heartBeatCallback(extension_packet.from)
                            },
                                localConfig.heartBeatTimeout);

                            // set the on screen status for this extension
                            setExtensionStatus(extension_packet.from, extension_packet.data)

                        }
                    }
                    // -------------------------------------------------------------------------------------------------
                    //                           STREAMLABS_ALERT
                    // -------------------------------------------------------------------------------------------------
                    else if (server_packet.dest_channel === "STREAMLABS_ALERT")
                        ProcessStreamAlert(server_packet);
                    // -------------------------------------------------------------------------------------------------
                    //                           STREAMLABS_ALERT
                    // -------------------------------------------------------------------------------------------------
                    else if (server_packet.dest_channel === "CHATMOOD_CHANNEL")
                        console.log(extension_packet.data)
                    // -------------------------------------------------------------------------------------------------
                    //                           TWITCH_CHAT
                    // -------------------------------------------------------------------------------------------------
                    else if (server_packet.dest_channel == "TWITCH_CHAT")
                    {
                        if (extension_packet.type === "ChatMessage")
                        {
                            parseTwitchChatMessage(extension_packet.data);
                            displayChatMessages();
                        }
                    }
                    // -------------------------------------------------------------------------------------------------
                    //                           DISCORD_CHAT
                    // -------------------------------------------------------------------------------------------------
                    else if (server_packet.dest_channel == "DISCORD_CHAT")
                    {
                        parseDiscordChatMessage(server_packet.data.data);
                        //displayDiscordMessages(server_packet);
                        displayChatMessages();
                    }
                    // -------------------------------------------------------------------------------------------------
                    //                           DISCORD_CHAT
                    // -------------------------------------------------------------------------------------------------
                    else if (server_packet.dest_channel == "TIMERS")
                    {
                        processTimers(extension_packet.data);
                        UpdateOBSDefaultButtons();
                    }
                    // -------------------------------------------------------------------------------------------------
                    //                           OBS_CHANNEL
                    // -------------------------------------------------------------------------------------------------
                    else if (server_packet.dest_channel == "OBS_CHANNEL")
                    {
                        if (extension_packet.type === "ScenesList")
                            ParseOBSScenesList(extension_packet.data)
                        else if (extension_packet.type === "SceneChanged")
                        {
                            localConfig.OBSSceneslist.current = extension_packet.data;
                            ParseOBSScenesList(localConfig.OBSSceneslist);
                        }
                        else if (extension_packet.type === "OBSStats")
                        {
                            // need to check in case we missed the start message (stream already running when we load the page)
                            if (!localConfig.obslive)
                            {
                                localConfig.obslive = extension_packet.data.obslive;
                                OBSLiveCheck();
                            }

                            ProcessOBSStats(extension_packet.data);
                        }
                        else if (extension_packet.type === "StreamStarted")
                        {
                            localConfig.obslive = true;
                            OBSLiveCheck();
                            // send tweet to say we are live
                            if (serverConfig.twitterstartenabled)
                                postMessageToTwitter(serverConfig.twitterstartmessage, serverConfig.twitterstartmessage_x);
                        }
                        else if (extension_packet.type === "StreamStopped")
                        {
                            localConfig.obslive = false;
                            OBSLiveCheck();
                        }
                        else if (extension_packet.type === "MuteStatus")
                        {
                            if (extension_packet.data.scene === serverConfig.mutescene)
                            {
                                serverConfig.muted = extension_packet.data.muted
                                addOBSMuteButton(serverConfig.muted)
                                OBSLiveCheck();
                            }
                        }
                        else
                            console.log(".onDataCenterMessage", "OBS_CHANNEL message ignored ", extension_packet.type, " from ", extension_packet.from);
                    }
                    else if (server_packet.dest_channel == "STREAMERSONGLIST_CHANNEL")
                    {
                        if (extension_packet.type == "SongQueue")
                            updateSingerSonglistQueue(extension_packet.data)
                        else if (extension_packet.type == "SongList")
                            updateSingerSonglistList(extension_packet.data.items)
                    }
                    // -------------------------------------------------------------------------------------------------
                    //                           UNHANDLED CHANNEL DATA
                    // -------------------------------------------------------------------------------------------------
                    else
                    {
                        console.log(".onDataCenterMessage", "Channel Data " + server_packet.dest_channel + " not handled");
                    }
                }
                // -------------------------------------------------------------------------------------------------
                //                           UNKNOWN CHANNEL MESSAGE RECEIVED
                // -------------------------------------------------------------------------------------------------
                else if (server_packet.type === "UnknownChannel")
                {
                    //channel might not exist yet, extension might still be starting up so lets rescehuled the join attempt
                    // need to add some sort of flood control here so we are only attempting to join one at a time
                    if (server_packet.data.message.dest_channel != "")
                    {
                        console.log(".onDataCenterMessage", "Channel " + server_packet.channel + " doesn't exist, scheduling rejoin");
                        setTimeout(() =>
                        {

                            sr_api.sendMessage(DataCenterSocket,
                                sr_api.ServerPacket(
                                    "JoinChannel",
                                    serverConfig.extensionname,
                                    server_packet.data.message.dest_channel
                                ));
                        }, 10000);
                    }
                    else
                        console.log(".onDataCenterMessage", "Channel " + server_packet.channel + " doesn't exist, skipping rejoin (extension has probably not started up and created a channel yet", server_packet.data);

                    // -------------------------------------------------------------------------------------------------
                    //                           IGNORING THESE MESSAGE (to save loging them)
                    // -------------------------------------------------------------------------------------------------
                } else if (server_packet.type === "ChannelJoined"
                    || server_packet.type === "ChannelCreated"
                    || server_packet.type === "ChannelLeft"
                )
                {
                    // just a blank handler for items we are not using to avoid message from the catchall
                }
                // ------------------------------------------------ unknown message type received -----------------------------------------------
                else
                    console.log(".onDataCenterMessage", "Unhandled message type:", server_packet);
            }
            // ============================================================================
            //                           FUNCTION: heartBeatCallback
            // ============================================================================
            // Desription: started when we get a heartbeat and used to mark the extension as down if it expires
            // Parameters: extension name and the state (true fals to represent status)
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            function heartBeatCallback (extensionname)
            {
                setExtensionStatus(extensionname, false);
            }
            // ============================================================================
            //                           FUNCTION: SaveConfigToServer
            // ============================================================================
            function SaveConfigToServer ()
            {
                // saves our serverConfig to the server so we can load it again next time we startup
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket(
                        "SaveConfig",
                        serverConfig.extensionname,
                        serverConfig,
                    ));
            }
            // ============================================================================
            //                           FUNCTION: loadExtensionCards
            // ============================================================================
            // Desription: display message in allmessages card
            // Parameters: list of extension names
            // ----------------------------- notes ----------------------------------------
            // There is a bug here. If the backend restarts and the page isn't 
            // refreshed then any callbacks from the froms will fail. fix was to 
            // force a fresh of the page when a new extension list comes in. Not very
            // smooth :(
            // ===========================================================================
            function loadExtensionCards (extensions)
            {
                extensions.sort()
                // First we create all the links (these may be changed below if the extension has provided a modal box)
                var html = "<div>";
                for (var i = 0; i < extensions.length; i++)
                {
                    // if we have an extension and it is set to displayaddModal
                    if (!adminData.extensions[extensions[i]])
                    {
                        adminData.extensions[extensions[i]] = {};
                        adminData.extensions[extensions[i]].display = false;
                        RequestAdminModalsCode(extensions[i]);
                    }

                    html += "<div  id='" + extensions[i] + "_visibility_admincard' style='display: none;'> <span id='" + extensions[i] + "_status' class='extensioncardicon'>&#x2B24</span>";
                    html += " <span id='" + extensions[i] + "'>"
                    html += extensions[i] + "</span></div>";

                };
                //html += "</ul>";
                html += "</div>";
                document.getElementById("ExtensionsListCard").getElementsByClassName("card-title")[0].innerHTML = "ExtensionsList";
                document.getElementById("ExtensionsListCard").getElementsByClassName("card-text")[0].innerHTML = html;

                //document.getElementById("ExtensionsListCard").getElementsByClassName("card-text")[0].addRule('li:before', { 'color': 'red' });
                // lets check if we have a previous adminmodal card for this extension and if so add it to the link above
                for (var i = 0; i < extensions.length; i++)
                    if (adminData.extensions[extensions[i]].admincard)
                        addModal(extensions[i], adminData.extensions[extensions[i]].admincard)
            }
            // ===========================================================================
            //                           FUNCTION: SendModal
            // ===========================================================================
            // Desription: Send the modal code back after setting the defaults according 
            // to our server settings
            // Parameters: channel to send data to
            // ----------------------------- notes ---------------------------------------
            // none
            // ===========================================================================
            function SendModal (toextension)
            {
                let modalstring = adminData.extensions[serverConfig.extensionname].admincard;
                // first lets update our modal to the current settings
                for (const [key, value] of Object.entries(serverConfig))
                {
                    // true values represent a checkbox so replace the "[key]checked" values with checked
                    if (value === "on")
                        modalstring = modalstring.replace(key + "checked", "checked");
                    else if (typeof (value) == "string" || typeof (value) == "number")
                        modalstring = modalstring.replace('"' + key + 'text"', '"' + value + '"');
                }
                // send the modal data to the server
                // send the modal data to the server
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket(
                        "ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "AdminModalCode",
                            serverConfig.extensionname,
                            modalstring,
                            "",
                            toextension
                        ),
                        "",
                        toextension
                    ));
            }
            // ============================================================================
            //                           FUNCTION: addModal
            // ============================================================================
            // Desription: Add the modal code from the extension to the link
            // Parameters: 
            //          xname - name of extension
            //          data  - data to add
            // ----------------------------- notes ----------------------------------------
            // None
            // ===========================================================================
            function addModal (xname, data)
            {
                // only update modals if we have received the extension name from the server
                if (adminData.extensions[xname])
                {
                    let modalbox = document.getElementById("ExtensionSettingsPlaceholder").children[0];
                    // grab the <li> element for this extension
                    let extLiTag = document.getElementById(xname);
                    if (document.getElementById(xname + "_visibility_admincard") == null)
                        return
                    document.getElementById(xname + "_visibility_admincard").style.display = "";
                    // remove the previous event listener (if there was one)
                    $('#' + xname + "_modal").off('submit');
                    //set the element contents to a blank extension placeholder
                    // if we have already set this element to the placeholder page we don't want to do it again
                    // otherwise it will replace the submit callback and throw an error when updated a second time.
                    if (extLiTag.innerHTML === xname)
                        extLiTag.innerHTML = modalbox.innerHTML;
                    // setup the link to show the dialog
                    extLiTag.getElementsByClassName("ext-modal-link")[0].href = "#" + xname + "_modal";
                    extLiTag.getElementsByClassName("ext-modal-link")[0].innerHTML = xname;
                    extLiTag.getElementsByClassName("modal")[0].id = xname + "_modal";
                    // set the data from the extension
                    document.getElementById(xname + "_modal").innerHTML = data;
                    // add a callback handle
                    $('#' + xname + "_modal").on('submit', function (event)
                    {
                        event.preventDefault();
                        // if it is our own modal that has changed (another page has submitted one
                        // we need to process it ourselves first
                        if (xname == serverConfig.extensionname)
                        {
                            // process this data oursleves first
                            processOwnModalSubmit(xname);
                            // now it is processed we can parse it
                            UpdateAdminModalData()
                            // As we have some updateded data we need to make sure that we refresh ourselves in case
                            // we have changed some settings (ie buttons to be shown)
                            ParseOBSScenesList(localConfig.OBSSceneslist);
                            // update anyone that has our modal
                            SendModal("");
                            setCardsVisibility();
                        }
                        else
                            parseExtensionModalData(xname);
                        return false;
                    });
                    document.getElementById(xname + "_visibility_admincard").style.display = "block"
                    adminData.extensions[xname].admincard = document.getElementById(xname).innerHTML

                }
                // need to update the mode in case we have received a light mode 
                // modal and we are in dark mode
                refreshDarkMode();
            }
            // ============================================================================
            //                           FUNCTION: setExtensionStatus
            // ============================================================================
            function setExtensionStatus (extension, status)
            {
                if (!status.connected || status == "false")
                    document.getElementById(extension + "_status").style = "color:red";
                else if (status.readonly)
                    document.getElementById(extension + "_status").style = "color:orange";
                else
                    document.getElementById(extension + "_status").style = "color:green";
                document.getElementById(extension + "_visibility_admincard").style.display = "";
            }
            // ============================================================================
            //                           FUNCTION: UpdateOBSDefaultButtons
            // ============================================================================
            function UpdateOBSDefaultButtons ()
            {
                var element = document.getElementById("OBSDefaultButtons");
                element.textContent = "";

                if (localConfig.timers.StartCountdownTimer != undefined && localConfig.timers.StartCountdownTimer > 0)
                {
                    let minutes = Math.floor(localConfig.timers.StartCountdownTimer / 60);
                    let seconds = localConfig.timers.StartCountdownTimer - (minutes * 60);
                    addOBSSceneButton(element, minutes.toString().padStart(2, '0') + ":" + seconds.toString().padStart(2, '0'), serverConfig.obsdefaultstartscenename, localConfig.OBSSceneslist.current)
                }
                else
                    addOBSSceneButton(element, "Start", serverConfig.obsdefaultstartscenename, localConfig.OBSSceneslist.current)
                addOBSSceneButton(element, "Live", serverConfig.obsdefaultlivescenename, localConfig.OBSSceneslist.current)
                addOBSSceneButton(element, "Intermission", serverConfig.obsdefaultintermissionscenename, localConfig.OBSSceneslist.current)
                addOBSSceneButton(element, "End", serverConfig.obsdefaultendscenename, localConfig.OBSSceneslist.current)
            }
            // ============================================================================
            //                           FUNCTION: ParseOBSScenesList
            // ============================================================================
            function ParseOBSScenesList (data)
            {
                let primaryScenes = data.main;
                let secondaryScenes = data.secondary;
                let restScenes = data.rest;
                let foundmutedscene = false;
                // remove the existing buttons
                var element = document.getElementById("OBSButtons");
                //remove the old buttons
                element.textContent = ""
                //store the data incase the user updated what they want to display
                localConfig.OBSSceneslist = data;
                // update default buttons
                UpdateOBSDefaultButtons();

                // always show the primary scene list
                if (typeof (primaryScenes) !== "undefined" &&
                    (serverConfig.showallscenes === "on" || serverConfig.showprimaryscenes === "on")
                )
                {
                    primaryScenes.forEach((scene) => 
                    {
                        addOBSSceneButton(element, scene.displayName, scene.sceneName, data.current);
                        if (scene.displayName === serverConfig.mutescene)
                        {
                            foundmutedscene = true;
                            addOBSMuteButton(scene.muted);
                        }
                    });
                }
                // if we have all or secondory selected to show then show both 'secondary' list and 'rest' list
                if (typeof (secondaryScenes) !== "undefined" && (serverConfig.showallscenes === "on" || serverConfig.showsecondaryscenes === "on"))
                {
                    secondaryScenes.forEach((scene) => 
                    {
                        addOBSSceneButton(element, scene.displayName, scene.sceneName, data.current);
                        if (scene.displayName === serverConfig.mutescene)
                        {
                            foundmutedscene = true;
                            addOBSMuteButton(scene.muted);
                        }
                    });
                }
                // only show remaining scenes if all is set
                if (typeof (restScenes) !== "undefined" && serverConfig.showallscenes === "on")
                {
                    restScenes.forEach((scene) => 
                    {
                        addOBSSceneButton(element, scene.displayName, scene.sceneName, data.current)
                        if (scene.displayName === serverConfig.mutescene)
                        {
                            foundmutedscene = true;
                            addOBSMuteButton(scene.muted);
                        }
                    })
                    // Add mute button
                }
                if (!foundmutedscene)
                    addOBSMuteButton(serverConfig.muted);
                // check if we are live and set the colors accordingly.
                OBSLiveCheck();
            }
            // ============================================================================
            //                           FUNCTION: addOBSSceneButton
            // ============================================================================
            function addOBSSceneButton (element, displayname, scenename, current)
            {
                button = document.createElement('input');
                button.type = 'button';
                button.value = displayname;
                if (scenename === current)
                    button.classList = "btn btn-success";
                else
                    button.classList = "btn btn-secondary";
                button.addEventListener('click', function ()
                {
                    event.preventDefault();
                    sr_api.sendMessage(DataCenterSocket,
                        sr_api.ServerPacket(
                            "ExtensionMessage",
                            serverConfig.extensionname,
                            sr_api.ExtensionPacket(
                                "ChangeScene",
                                serverConfig.extensionname,
                                scenename,
                                "",
                                "obs"
                            ),
                            "",
                            "obs"
                        )
                    )
                    return false;
                }, false);

                element.appendChild(button);
            }
            // ============================================================================
            //                           FUNCTION: addOBSMuteButton
            // ============================================================================
            function addOBSMuteButton (muted)
            {
                button = document.createElement('input');
                button.type = 'button';
                button.value = "Mute";
                if (muted)
                    button.classList += "btn btn-danger";
                else
                    button.classList += "btn btn-secondary";
                button.addEventListener('click', function ()
                {
                    event.preventDefault();
                    sr_api.sendMessage(DataCenterSocket,
                        sr_api.ServerPacket(
                            "ExtensionMessage",
                            serverConfig.extensionname,
                            sr_api.ExtensionPacket(
                                "ToggleMute",
                                serverConfig.extensionname,
                                serverConfig.mutescene,
                                "",
                                "obs"
                            ),
                            "",
                            "obs"
                        )
                    )
                    return false;
                }, false);

                //remove the old button
                document.getElementById("OBSMute").textContent = ""
                // add the new one
                document.getElementById("OBSMute").appendChild(button);
            }
            // ============================================================================
            //                           FUNCTION: OBSLiveCheck
            // ============================================================================
            function OBSLiveCheck ()
            {
                let livebackbround = document.getElementById("OBSControllsCard");
                // check if we are live
                if (localConfig.obslive)
                {
                    // currently set to live so lets set the background to green
                    // remove the normal colors
                    livebackbround.classList.remove('bg-light');
                    livebackbround.classList.remove('text-light');
                    livebackbround.classList.remove('bg-dark');
                    livebackbround.classList.remove('text-dark');
                    livebackbround.style["background-color"] = "#013301";
                    livebackbround.style["color"] = "white";
                    // remove any previous colors for the background
                }
                else
                {
                    // not live anymore so set the background back to normal
                    document.getElementById("OBSStrain").style.removeProperty("background-color")
                    // background is set in the navbar partial code and uses local storage. should probably update this and move it here
                    if (localStorage.getItem("darkmode") === "true")
                    {
                        livebackbround.classList.remove('bg-light');
                        livebackbround.classList.remove('text-dark');
                        livebackbround.classList.add('bg-dark');
                        livebackbround.classList.add('text-light');
                    }
                    else
                    {
                        livebackbround.classList.remove('bg-dark');
                        livebackbround.classList.remove('text-light');
                        livebackbround.classList.add('bg-light');
                        livebackbround.classList.add('text-dark');
                    }
                }
            }
            // ============================================================================
            //                           FUNCTION: ProcessOBSStats
            // ============================================================================
            // Desription:save config on backend data store
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // 
            /*{
          "averageFrameTime": 24.81013,
          "bytesPerSec": 60795,
          "cpuUsage": 18.0699481865285,
          "freeDiskSpace": 348106.8203125,
          "kbitsPerSec": 474,
          "memoryUsage": 468.78125,
          "numDroppedFrames": 0,
          "numTotalFrames": 44,
          "outputSkippedFrames": 0,
          "outputTotalFrames": 57,
          "previewOnly": false,
          "recordingPaused": false,
          "renderMissedFrames": 4,
          "renderTotalFrames": 2932,
          "replayBufferActive": false,
          "streamTimecode": "00:00:01.466",
          "totalStreamTime": 1,
          "updateType": "StreamStatus"
          */

            // ===========================================================================
            function ProcessOBSStats (data)
            {
                if (localConfig.obslive)
                {
                    //let rate = data.outputBytes;
                    let strain = data.outputCongestion; // red/green/amber icon needed
                    var straincolor = (255 / 1 * strain);
                    var Uptime = "";

                    // saves our serverConfig to the server so we can load it again next time we startup
                    if (data.totalStreamTime > 0)
                    {
                        hour = Math.floor((data.totalStreamTime / 1000 / 3600) << 0)
                        min = Math.floor((data.totalStreamTime / 1000 / 60) << 0)
                        sec = Math.floor((data.totalStreamTime / 1000) % 60);
                        if (hour > 0)
                            Uptime = "Uptime:<BR>" + hour + ":" + (min - (hour * 60)) + ":" + sec
                        else
                            Uptime = "Uptime:<BR>" + hour + ":" + min + ":" + sec
                    }

                    document.getElementById("OBSUptime").innerHTML = Uptime;
                    //document.getElementById("OBSRate").innerHTML = "Rate:<BR>" + rate + " kb/s";

                    let missedframes = data.renderSkippedFrames;
                    let skippedframes = data.outputSkippedFrames;
                    // add coloring if we drop too many frames and we also truncat the numbers if over 10k
                    if (missedframes > 1000)
                    {
                        if (missedframes > 10000)
                            missedframestxt = (~~(missedframes / 1000)) + "k"
                        missedframestxt = "<span style='color:red'>Render errors:<BR>" + missedframestxt + "</span>";
                    }
                    else if (missedframes > 0)
                        missedframestxt = "<span style='color:orange'>Render errors:<BR>" + missedframes + "</span>";
                    else
                        missedframestxt = "<span style='color:green'>Render errors:<BR>" + missedframes + "</span>";

                    if (skippedframes > 1000)
                    {
                        if (skippedframes > 10000)
                            skippedframestxt = (~~(skippedframes / 1000)) + "k"
                        skippedframestxt = "<span style='color:red'>Network frames errors:<BR>" + skippedframestxt + "</span>";
                    }
                    else if (skippedframes > 0)
                        skippedframestxt = "<span style='color:orange'>Network frames errors:<BR>" + skippedframes + "</span>";
                    else
                        skippedframestxt = "<span style='color:green'>Network frames errors:<BR>" + skippedframes + "</span>";

                    // note the double not (~) removes the decimal part more efficiently than the match.trunc fungion
                    if (data.renderTotalFrames > 1000)
                        document.getElementById("OBSRender").innerHTML = missedframestxt + "/" + (~~(data.renderTotalFrames / 1000)) + "k";
                    else
                        document.getElementById("OBSRender").innerHTML = missedframestxt + "/" + data.renderTotalFrames;
                    if (data.outputTotalFrames > 1000)
                        document.getElementById("OBSNetwork").innerHTML = skippedframestxt + "/" + (~~(data.outputTotalFrames / 1000)) + "k";
                    else
                        document.getElementById("OBSNetwork").innerHTML = skippedframestxt + "/" + data.outputTotalFrames;

                    document.getElementById("OBSStrain").style["background-color"] = "rgb(" + straincolor + "," + (255 - straincolor) + ",0)";
                }
            }
            // ============================================================================
            //                      FUNCTION: parseExtensionModalData
            // ============================================================================
            // Desription: This function will retireve the data from the modal and 
            // send the push the data out so others can update theirs to reflect the change
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // None
            // ===========================================================================
            function parseExtensionModalData (extension)
            {
                let fieldsAsArray = $('#' + extension + "_modal").serializeArray();
                // convert our array of objects into a more usable objet
                var fieldsAsObject = fieldsAsArray.reduce((obj, item) => (obj[item.name] = item.value, obj), {});
                if (fieldsAsObject.extensionname)
                    sr_api.sendMessage(DataCenterSocket,
                        sr_api.ServerPacket(
                            "ExtensionMessage",
                            serverConfig.extensionname,
                            sr_api.ExtensionPacket(
                                fieldsAsObject.modaldatatype,
                                serverConfig.extensionname,
                                fieldsAsObject,
                                "",
                                fieldsAsObject.extensionname),
                            "",
                            fieldsAsObject.extensionname
                        ));

            }
            // ============================================================================
            //                      FUNCTION: UpdateAdminModalData
            // ============================================================================
            // Desription: Update our own modal if our config has changed
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // 
            // ===========================================================================
            function UpdateAdminModalData ()
            {
                //get the updated dom we just changed and change the rest using sting replace
                let modalstring = document.getElementById("liveportalmodalplaceholder").innerHTML;
                for (const [key, value] of Object.entries(serverConfig))
                {
                    // checkboxes
                    if (value === "on")
                        modalstring = modalstring.replace(key + 'checked', 'checked');
                    else if (key === "randomfactstimeout")
                        modalstring = modalstring.replace('"' + key + 'text"', '"' + (value / 60000) + '"');
                    // replace text strings
                    else if (typeof (value) == "string" || typeof (value) == "number")
                        modalstring = modalstring.replaceAll('"' + key + 'text"', '"' + value + '"');
                }
                adminData.extensions[serverConfig.extensionname].admincard = modalstring;
                //document.getElementById(serverConfig.extensionname + "_modal").innerHTML = modalstring;
                // Update the OBS channel list as we might have changed what we want to show
                ParseOBSScenesList(localConfig.OBSSceneslist);
                addModal(serverConfig.extensionname, modalstring)
            }
            // ============================================================================
            //                      FUNCTION: processOwnModalSubmit
            // ============================================================================
            // Desription: This function will retireve the data from the modal and 
            // send save it in the serverConfig after we hit the submit button
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // None
            // ===========================================================================
            function processOwnModalSubmit (name)
            {
                // get the modal data as an array
                let fieldsAsArray = $('#' + name + "_modal").serializeArray();
                // convert our array of objects into a more usable object
                var fieldsAsObject = fieldsAsArray.reduce((obj, item) => (obj[item.name] = item.value, obj), {});
                if (fieldsAsObject.logginglevel != serverConfig.logginglevel)
                {
                    // change server logging level
                    changeServerLogging(fieldsAsObject.logginglevel);
                    serverConfig.logginglevel = fieldsAsObject.logginglevel;
                }
                // loop though our keys and set them to match what is in the modal
                for (const [key, value] of Object.entries(serverConfig))
                {
                    //lets check our settings and send out updates as required
                    if (key === "modmessage_channel")
                    {
                        // udpate the server (or just refresh the value even if the same)
                        changeDiscordListeningChannel(serverConfig[key]);
                        serverConfig[key] = fieldsAsObject[key];
                    }
                    else if (key === "randomfactstimeout")
                        serverConfig[key] = fieldsAsObject[key] * 60000
                    else if (value === "on" && !fieldsAsObject[key])
                        serverConfig[key] = "off";
                    else if (key in fieldsAsObject)
                        serverConfig[key] = fieldsAsObject[key];
                }
                //save the data to the server
                SaveConfigToServer();
            }
            // ============================================================================
            //                           FUNCTION: changeServerLogging
            // ============================================================================
            function changeServerLogging (logsetting)
            {
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket(
                        "SetLoggingLevel",
                        serverConfig.extensionname,
                        logsetting,
                    ));
            }
            // ============================================================================
            //                           FUNCTION: displayChatMessages
            // ============================================================================
            // display buffers on screen
            // if parse=false is passed then the buffer isn't parsed, just update the screen
            function displayChatMessages ()
            {
                // parse the messages and add them to the buffer
                //        if (parse)
                //            parseTwitchChatMessages(data.data);
                let chatcardref = document.getElementById("ChatMessagesCardText")
                let modcardref = document.getElementById("ModMessagesCardText")

                // limit chat buffer to the number of lines we want to use
                while (localConfig.chatMessageBuffer.length > serverConfig.chatmessagebuffermaxsize)
                    localConfig.chatMessageBuffer.shift();

                // limit chat buffer to the number of lines we want to use
                while (localConfig.modMessageBuffer.length > serverConfig.modmessagebuffermaxsize)
                    localConfig.modMessageBuffer.shift();

                // add the buffer into the chat window
                chatcardref.innerHTML = localConfig.chatMessageBuffer.join(" ");
                modcardref.innerHTML = localConfig.modMessageBuffer.join(" ");

                // Auto scroll the boxes unless we have a new buffer, then we scroll to the end
                if (!localConfig.newTwitchChatBuffer)
                    MessageboxAutoscroll("ChatMessagesCardText")
                else
                {
                    const cardref = document.getElementById("ChatMessagesCardText")
                    const cardScrollHeight = cardref.scrollHeight;
                    cardref.scrollTo(0, cardScrollHeight + 5);
                    localConfig.newTwitchChatBuffer = false;
                }

                if (!localConfig.newDiscordChatBuffer)
                    MessageboxAutoscroll("ModMessagesCardText")
                else
                {
                    const cardref = document.getElementById("ModMessagesCardText")
                    const cardScrollHeight = cardref.scrollHeight;
                    cardref.scrollTo(0, cardScrollHeight + 5);
                    localConfig.newDiscordChatBuffer = false;
                }

            }
            // ============================================================================
            //                           FUNCTION: processTwitchChatBuffer
            // ============================================================================
            // Desription: Processes a message from the data center with the previous chat buffer
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            async function processTwitchChatBuffer (chatdata)
            {
                let counter = 0
                // as we have received a bufer lets delete the old data
                document.getElementById("ChatMessagesCardText").innerHTML = "";

                localConfig.chatMessageBuffer = [];
                chatdata.forEach(ele => 
                {
                    parseTwitchChatMessage(ele);
                })
                localConfig.chatMessageBuffer.push("<BR>--------- buffer loaded --------");

            }
            // ============================================================================
            //                           FUNCTION: processTwitchAccountNames
            // ============================================================================
            // Desription: Processes a message from the data center with the previous chat buffer
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            async function processTwitchAccountNames (extension_packet)
            {
                // as we have received a bufer lets delete the old data
                let newchatternames = ""
                localConfig.usernamelist = extension_packet.data;
                // if we have a username set in our config and that is in the current list of names lets use that one
                if (serverConfig.chatAsUsername && Object.values(extension_packet.data).indexOf(serverConfig.chatAsUsername) > -1)
                {
                    document.getElementById("chatuserselect").innerHTML = serverConfig.chatAsUsername;
                }
                // if we don't have a valid username then use the first one in the list passed in
                else if (extension_packet.data && extension_packet.data[0])
                {
                    document.getElementById("chatuserselect").innerHTML = extension_packet.data[0];
                    serverConfig.chatAsUsername = extension_packet.data[0];
                }
                else
                    document.getElementById("chatuserselect").innerHTML = "Select a User to chat as";

                twitchnamedropdowns = document.getElementById("chatuserchattername");
                for (const [key, value] of Object.entries(extension_packet.data)) 
                {
                    newchatternames += "<li><a id='" + value + "_user_select' class='dropdown-item' href='#' value=" + value + " onClick='userDropdownChanged( this )'>" + value + "</a></li>"
                }
                twitchnamedropdowns.innerHTML = newchatternames

            }
            // ============================================================================
            //                           FUNCTION: userDropdownChanged
            // ============================================================================
            // Desription: user has changed the account in the twitch chat box
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            function userDropdownChanged (e)
            {
                document.getElementById("chatuserselect").innerHTML = e.innerHTML;
                // if we have changed users update the config to remember it
                if (serverConfig.chatAsUsername != e.innerHTML)
                {
                    serverConfig.chatAsUsername = e.innerHTML;
                    SaveConfigToServer()
                }
            }
            // ============================================================================
            //                           FUNCTION: processDiscordChatBuffer
            // ============================================================================
            // Desription: Processes a message from the data center with the previous chat buffer
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            async function processDiscordChatBuffer (chatdata)
            {
                let counter = 0
                // as we have received a bufer lets delete the old data
                document.getElementById("ModMessagesCardText").innerHTML = "";
                localConfig.modMessageBuffer = [];

                if (chatdata)
                    chatdata.forEach(ele => 
                    {
                        parseDiscordChatMessage(ele);
                    })
                localConfig.modMessageBuffer.push("<BR>--------- buffer loaded --------");
            }
            // ============================================================================
            //                           FUNCTION: parseTwitchChatMessage
            // ============================================================================
            // updates the buffer with the messages
            function parseTwitchChatMessage (chatdata)
            {
                if (chatdata.data["message-type"] == "Redemption")
                    console.log("redemption messsage received")
                try
                {
                    // highlights messages we have yet to put options in for
                    var messages_handled = ["chat", "action", "resub", "join", "connecting", "logon", "connected", "twitchchat_extension", "disconnected", "reconnect"]
                    var sub_messages = ["sub", "resub"];
                    //colors
                    //general use colors
                    var default_darkred_color = "darkred"

                    //specific fields / tags color
                    var default_greyout_color = "#757875"
                    var default_system_color = "red"
                    var default_username_color = "#6f42c1"
                    var default_timecode_color = "#757875"

                    var default_user_at_color = "red"
                    var default_TBD_background_color = "purple"
                    var default_TBD_text_color = "yellow"
                    var default_text_bright_color = "white"
                    var default_sub_color = "limegreen"
                    var default_reward_color = "orange"


                    var today = new Date();
                    var time = today.getHours() + ":" + String(today.getMinutes()).padStart(2, '0') + ":" + String(today.getSeconds()).padStart(2, '0');
                    // make it colorful
                    var time_color = "<span style='color: " + default_timecode_color + "'>";
                    var end_time_color = "</span>"
                    var user_color = "";
                    var end_user_color = "";
                    var background_color = "";
                    var end_background_color = "";
                    var user_icons = "";
                    var action = "";
                    var endaction = "";
                    var highlight_message = "<span style='background-color: " + default_darkred_color + "; '>";
                    var highlight_message = "</>";
                    var mod_badge = "<img src='liveportal/images/badge_mod.png'>";

                    var greyout_line = "false";

                    // three main parts of a message are built up into these tags
                    // linefield + time_field + name_field + message_field + endline_field
                    var time_field = time_color + time + ":" + end_time_color;
                    var name_field = "";
                    var message_field = "";
                    var line_field = "<BR><span>";
                    var end_line_field = "</span>";

                    // lets sanitise the message before we add the emotes
                    // we do this by pushing it into an html div and then pulling it out again
                    // kind of a hack but it works :D
                    var sanitiser = document.createElement('div');
                    sanitiser.innerText = chatdata.message
                    var message = sanitiser.innerHTML
                    // set the window title (might have updated)
                    document.getElementById("ChatMessagesCardTitle").innerHTML = "Chat: " + chatdata.channel


                    // check for an action messge '/me'
                    if (chatdata.data["message-type"] == "action")
                    {
                        action = "<i>";
                        endaction = "</i>"
                    }
                    // check for highlighted message
                    if (chatdata.data["msg-id"] == "hightlithghted-message" || chatdata.data["message-type"] == "Redemption")
                    {
                        highlight_message = true
                    }
                    // if we have a non chat or action message highlight it (indicates we still need to handle these messages)
                    if (!(messages_handled.includes(chatdata.data["message-type"])))
                    {
                        console.log("Under Construction: Chat message still needs to be parsed.")
                        console.log(chatdata)
                        background_color = "<span style='color:" + default_TBD_text_color + "; background-color: " + default_TBD_background_color + "; '>";
                        message = message + " <message-type>: " + ((chatdata.data["message-type"]) ? chatdata.data["message-type"] : "")
                        end_background_color = "</span>"
                    }



                    if (!chatdata.message)
                    {
                        console.log("########### EMPTY MESSAGE ##########")
                        console.log(chatdata);
                    }

                    // check if someone @'d us
                    if (localConfig.usernamelist.user && chatdata.message.toLowerCase().indexOf('@' + localConfig.usernamelist.user.toLowerCase()) > -1)
                    {
                        var myregex = new RegExp("@" + localConfig.usernamelist.user, "gi")
                        message = message.replace(myregex, "<span style='color:" + default_text_bright_color + ";background-color: " + default_user_at_color + ";'> @" + localConfig.usernamelist.user + "</span>")
                    }

                    // add any twitch emotes
                    message = addTwitchEmotes(message, chatdata.data.emotes);


                    // ##################### our bot messages ##############################
                    if (chatdata.data['display-name'] === localConfig.usernamelist.bot && chatdata.data["message-type"] == "chat")
                    {
                        user_color = mod_badge;
                        line_field = "<BR><span style='color: " + default_greyout_color + "'>"
                        name_field = chatdata.data['display-name'] + "> ";
                        if (highlight_message)
                            message_field = message;
                        // set the card data
                        localConfig.chatMessageBuffer.push(line_field + time_field + name_field + message_field + end_line_field);
                    }
                    // ##################### system messages ##############################
                    else if (chatdata.data['display-name'] === "System")
                    {
                        // set the card data
                        line_field = "<BR><span style='color: " + default_system_color + "'>"
                        name_field = chatdata.data['display-name'] + "> ";
                        message_field = message;
                        localConfig.chatMessageBuffer.push(line_field + time_field + name_field + message_field + end_line_field);
                        //localConfig.chatMessageBuffer.push("<BR><span style='color: " + default_system_color + "'>" + time + "::: " + chatdata.data['display-name'] + " " + message + "</span>");
                    }
                    // ##################### sub messages ##############################
                    else if (sub_messages.includes(chatdata.data["message-type"]))
                    {
                        line_field = "<BR><span style='color: " + default_sub_color + "'>"
                        name_field = "<b>" + chatdata.data['display-name'] + "> ";
                        message_field = chatdata.data['system-msg'] + ": " + message + "</b>";
                        localConfig.chatMessageBuffer.push(line_field + time_field + name_field + message_field + end_line_field);
                    }
                    // ##################### redeem ##############################
                    else if (chatdata.data["custom-reward-id"])
                    {
                        console.log(chatdata)
                        line_field = "<BR><span style='color: " + default_reward_color + "'>"
                        name_field = "<b>" + chatdata.data['display-name'] + "> ";
                        message_field = "Redemption: " + message + "</b>";
                        localConfig.chatMessageBuffer.push(line_field + time_field + name_field + message_field + end_line_field);
                    }
                    // ##################### chat messages ##############################
                    else
                    {
                        // ##################### username colors and icons
                        // if this is not a chat message (ie a sub etc) then set username color to yellow
                        if (chatdata.data["message-type"] != "chat")
                            user_color = "<span style='color: yellow'>";
                        // if the user is a mod then add the mod badge
                        else if (chatdata.data.mod)
                            user_color = "<img src='liveportal/images/badge_mod.png'><span style='color:" + chatdata.data.color + "'>";
                        // if we don't have a user color then lets use that instead
                        else if (chatdata.data.color === null)
                            user_color = "<span style='color: " + default_username_color + "'>";
                        // use standard color if no coler is available
                        else
                            user_color = "<span style='color: " + chatdata.data.color + "'>";

                        name_field = user_color + chatdata.data['display-name'] + "&gt</span> ";


                        // ########### create out message line
                        // set the card title (may have changed since last time around)


                        // if we have no nonchat or action message highlight it so we know we need to fix this
                        if (chatdata.data["message-type"] == "chat" && chatdata.data["message-type"] == "action")
                            message_field = background_color + action + message + endaction + end_background_color
                        else if (chatdata.data["message-type"] == "resub")
                            message_field = background_color + action + message + endaction + end_background_color
                        else // unhandled message
                            message_field = background_color + action + message + endaction + end_background_color






                        localConfig.chatMessageBuffer.push(line_field + time_field + name_field + message_field + "<" + chatdata.data["message-type"] + ">" + end_line_field);



                        // add mod messages to mod card if we have this option selected in the liveportal settings page
                        if (serverConfig.modchattomodwindow === "on" && chatdata.data.mod)
                            //localConfig.modMessageBuffer.push("<BR>" + time + username + " " + message);
                            localConfig.modMessageBuffer.push(line_field + time_field + name_field + message_field + "<" + chatdata.data["message-type"] + ">" + end_line_field);

                    }
                }
                catch (error)
                {
                    console.log("ERROR:parseTwitchChatMessage:", error)
                    console.error(error)
                }
            }
            // ============================================================================
            //                           FUNCTION: parseDiscordChatMessage
            // ============================================================================
            // updates the buffer with the messages
            function parseDiscordChatMessage (chatdata)
            {
                //let chatdata = data.data;
                let today = new Date();
                let time = today.getHours() + ":" + String(today.getMinutes()).padStart(2, '0') + ":" + String(today.getSeconds()).padStart(2, '0');
                // make it colorful
                let time_color = "<span style='color: #757875'>";
                var end_time_color = "</span>";
                let user_color = "";
                // https://cdn.discordapp.com/emojis/634006521180717067
                let message = parseDiscordEmojis(chatdata.message);
                // lets sanitise the message before we add the emotes
                var sanitiser = document.createElement('div');
                if (chatdata.name === "System")
                    localConfig.modMessageBuffer.push("<BR><span style='color: red'>" + time + ":" + chatdata.name + " " + message + "</span>");
                else
                {
                    user_color = "<span style='color: #6f42c1'>";
                    let username = user_color + ' ' + chatdata.name + "&gt</span>";
                    time = time_color + time + ":" + end_time_color;

                    localConfig.modMessageBuffer.push("<BR>" + time + ":" + username + " " + message);

                }
            }
            // ============================================================================
            //                           FUNCTION: addDiscordEmotes

            // ============================================================================
            function parseDiscordEmojis (message)
            {
                let index = message.indexOf('<');
                let is, ie, emoji = 0;
                let msg = message;
                let newmessage = ""
                if (msg.indexOf('<') == -1)
                    return message;

                // check if we have emoji. this should really be a bit better, ie a patternmatch (in the form of <name:id>)
                while (msg.indexOf('<') > 0)
                {
                    //log the start of the possible emoji
                    index = msg.indexOf('<');
                    // get the start of the id
                    is = msg.indexOf(':', index + 2);
                    // get the end of the id string
                    ie = msg.indexOf('>', index)
                    // get the first part of the message (up to the next emoji)
                    newmessage = newmessage + msg.slice(0, index);
                    // get the emoji
                    emoji = msg.slice(is + 1, ie);
                    // remove the message up to the emoji
                    msg = msg.slice(ie + 1); // skip past the first '<:'
                    // add the emoji to the message
                    newmessage = newmessage + "<img src='https://cdn.discordapp.com/emojis/" + emoji + "' width='25' height='25'>";
                }
                return newmessage;
            }
            // ============================================================================
            //                           FUNCTION: addTwitchEmotes
            // ============================================================================
            function addTwitchEmotes (message, emotes)
            {
                if (!emotes) return message;

                // store all emote keywords
                // ! you have to first scan through 
                // the message string and replace later
                const stringReplacements = [];
                let theme = "light"
                if (localStorage.getItem("darkmode") === "true")
                    theme = "dark"
                // iterate of emotes to access ids and positions
                Object.entries(emotes).forEach(([id, positions]) =>
                {
                    // use only the first position to find out the emote key word
                    const position = positions[0];
                    const [start, end] = position.split("-");
                    const stringToReplace = message.substring(
                        parseInt(start, 10),
                        parseInt(end, 10) + 1
                    );
                    stringReplacements.push({
                        stringToReplace: stringToReplace,
                        //replacement: `<img src="https://static-cdn.jtvnw.net/emoticons/v1/${id}/1.0">`,
                        replacement: "<img src='https://static-cdn.jtvnw.net/emoticons/v2/" + id + "/default/" + theme + "/1.0'>"
                    });
                });

                // generate HTML and replace all emote keywords with image elements
                const messageHTML = stringReplacements.reduce(
                    (acc, { stringToReplace, replacement }) =>
                    {
                        // obs browser doesn't srsmm to know about replaceAll
                        return acc.split(stringToReplace).join(replacement);
                    },
                    message
                );

                return messageHTML.replaceAll("\n", " ");;
            }

            // ============================================================================
            //                           FUNCTION:DisplayAlertMessages
            // ============================================================================
            // Desription: display alerts
            // Parameters: alert message
            // ----------------------------- notes ----------------------------------------
            // None
            // ===========================================================================
            function DisplayAlertMessages (message)
            {
                let cardref = document.getElementById("AlertCardText");
                cardref.innerHTML = cardref.innerHTML + message
                // keep scroll at the bottom of the card
                var cardScrollHeight = cardref.scrollHeight;
                cardref.scrollTo(0, cardScrollHeight + 1);
            }

            // ============================================================================
            //                           FUNCTION:MessageboxAutoscroll
            // ============================================================================
            // Desription: keeps a message box scrolled if user hasn't scrolled up
            // Parameters: e
            // ----------------------------- notes ----------------------------------------
            // None
            // ===========================================================================
            function MessageboxAutoscroll (messageBoxName)
            {
                let container = document.getElementById(messageBoxName)
                // only scroll if the mouse isn't down (user srolling) or if we are already 
                // within 40 pixels of the new mesages coming in. 
                if (!localConfig.mouseDown && ((container.scrollHeight - (container.scrollTop + container.clientHeight)) < 40))
                    container.scrollTop = container.scrollHeight;

            }
            // ============================================================================
            //                           FUNCTION: RequestExtList
            // ============================================================================
            // Desription: Sends a message to the data center to get the list of extensions
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            function RequestExtList ()
            {
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket(
                        "RequestExtensionsList",
                        serverConfig.extensionname,
                    ));
            }
            // ============================================================================
            //                           FUNCTION: RequestOBSScenes
            // ============================================================================
            // Desription: Sends a message to the data center to get the list of extensions
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            function RequestOBSScenes (to)
            {
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket(
                        "ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "RequestScenes",
                            serverConfig.extensionname,
                        ),
                        "",
                        to,
                    ));
            }
            // ============================================================================
            //                           FUNCTION: RequestChList
            // ============================================================================
            // Desription: Sends a message to the data center to get the list of channels
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            function RequestChList ()
            {
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket(
                        "RequestChannelsList",
                        serverConfig.extensionname,
                    ));
            }
            // ============================================================================
            //                           FUNCTION: RequestChatBuffer
            // ============================================================================
            // Desription: Sends a message to the data center to get the previous chat buffer
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            function RequestChatBuffer (extname)
            {
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket("ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "RequestChatBuffer",
                            serverConfig.extensionname,
                            "",
                            "",
                            extname),
                        "",
                        extname
                    ));
            }
            // ============================================================================
            //                           FUNCTION: RequestTwitchAccountNames
            // ============================================================================
            // Desription: Get our usernames from the twitch extension (so we can post as them)
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            function RequestTwitchAccountNames (extname)
            {
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket("ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "RequestAccountNames",
                            serverConfig.extensionname,
                            "",
                            "",
                            extname),
                        "",
                        extname
                    ));
            }
            // ============================================================================
            //                           FUNCTION: RequestAdminModalsCode
            // ============================================================================
            // Desription: Sends a message to the data center to get the list of extensions
            // Parameters: none
            // ----------------------------- notes ----------------------------------------
            // none
            // ===========================================================================
            function RequestAdminModalsCode (extname)
            {
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket("ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "RequestAdminModalCode",
                            serverConfig.extensionname,
                            "",
                            "",
                            extname),
                        "",
                        extname
                    ));
            }
            // ============================================================================
            //                           FUNCTION: RequestLoggingLevel
            // ============================================================================
            function RequestLoggingLevel ()
            {
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket(
                        "RequestLoggingLevel",
                        serverConfig.extensionname,
                    ));
            }
            // ============================================================================
            //                           FUNCTION: process_stream_alert
            // ============================================================================
            function ProcessStreamAlert (server_packet)
            {
                let alertdata = server_packet.data;
                // display the alert

                let alertcontents = alertdata.message[0];
                let messagetxt = "Thankyou ";
                let alerttext = "";
                console.log(alertdata.type)
                switch (alertdata.type)
                {
                    case "follow":
                        messagetxt += alertcontents.name + " for the follow."
                        if (serverConfig.follows === "on")
                            PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                        alerttext = "<div class='text-secondary'>Follow: " + alertcontents.name + "</div>";
                        DisplayAlertMessages(alerttext);
                        break;
                    case "raid":
                        messagetxt += alertcontents.name + " for the raid " + alertcontents.raiders + " raiders."
                        if (serverConfig.raids === "on")
                            PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                        alerttext = "<div class='text-success'>Raid: " + alertcontents.name + " " + alertcontents.raiders + "</div>";
                        DisplayAlertMessages(alerttext);
                        postMessageToTwitch("!so " + alertcontents.name)
                        break;
                    case "host":
                        messagetxt += alertcontents.name + " for the host with " + alertcontents.viewers + " viewers."
                        if (serverConfig.hosts === "on")
                            PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                        alerttext = "<div class='text-success'>Host: " + alertcontents.name + " " + alertcontents.viewers + "</div>";
                        DisplayAlertMessages(alerttext);
                        break;
                    case "donation":
                        if (alertcontents.message === null)
                            messagetxt += alertcontents.from + " for the " + alertcontents.formatted_amount + ' donation and helping keep the stream alive.'
                        else
                            messagetxt += alertcontents.from + " for the " + alertcontents.formatted_amount + ' donation and helping keep the stream alive. "' + alertcontents.message + '"'
                        if (serverConfig.donations === "on")
                            PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                        alerttext = "<div class='text-danger'>Donation: " + alertcontents.name + "  " + alertcontents.formatted_amount + ' "' + alertcontents.message + '"</div>';
                        DisplayAlertMessages(alerttext);
                        break;
                    case "bits":
                        if (alertcontents.message === null)
                            messagetxt += alertcontents.name + " for the " + alertcontents.amount + ' bits.'
                        else
                            messagetxt += alertcontents.name + " for the " + alertcontents.amount + ' bits. "' + alertcontents.message + '"'
                        if (serverConfig.bits === "on")
                            PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                        alerttext = "<div class='text-danger'>Bits: " + alertcontents.name + " " + alertcontents.amount + ' bits. "' + alertcontents.message + '"</div>';
                        DisplayAlertMessages(alerttext);
                        break;
                    case "subscription":
                        console.log(alertcontents)
                        if (alertcontents.type === "subgift" && alertcontents.gifter != null)
                        {
                            messagetxt += alertcontents.name + " was gifted a sub from " + alertcontents.gifter
                            if (serverConfig.subs === "on")
                                PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                            alerttext = "<div class='text-secondary'>&nbsp&nbsp&nbsp" + alertcontents.name + '</div>';
                            DisplayAlertMessages(alerttext);
                        }
                        else
                        {
                            let submessage = alertcontents.message;
                            if (submessage === null)
                                submessage = ""
                            if (alertcontents.months === 1)
                                messagetxt += alertcontents.name + " for the " + alertcontents.months + ' month subscription. "' + submessage + '"'
                            else
                                messagetxt += alertcontents.name + " for " + alertcontents.months + ' months of subscriptions. "' + submessage + '"'
                            if (serverConfig.subs === "on")
                                PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                            alerttext = "<div class='text-primary'>Subscription: " + alertcontents.name + " " + alertcontents.months + 'm "' + submessage + '"</div>';
                            DisplayAlertMessages(alerttext);
                        }
                        break;
                    case "resub":
                        if (alertcontents.message === null)
                            messagetxt += alertcontents.name + " for " + alertcontents.months + ' months of subcriptions (with a streak of ' + alertcontents.streak_months + ').'
                        else
                            messagetxt += alertcontents.name + " for " + alertcontents.months + ' months of subcriptions (with a streak of ' + alertcontents.streak_months + '). "' + alertcontents.message + '"'
                        if (serverConfig.resubs === "on")
                            PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                        alerttext = "<div class='text-primary'>Resub: " + alertcontents.name + " " + alertcontents.months + 'm (' + alertcontents.streak_months + '). "' + alertcontents.message + '"</div>';
                        DisplayAlertMessages(alerttext);
                        break;
                    case "subMysteryGift":
                        console.log(alertcontents)
                        messagetxt += alertcontents.gifter + " for the " + alertcontents.amount + " gifted subs"
                        postMessageToTwitch(messagetxt)
                        if (serverConfig.giftsubs === "on")
                            PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                        alerttext = "<div class='text-danger'>GiftSub: " + alertcontents.gifter + " gifted " + alertcontents.amount + " subs</div>"
                        DisplayAlertMessages(alerttext);
                        break;
                    case "merch":
                        messagetxt += alertcontents.from + " purchacing my merch. Hope you enjoy the " + alertcontents.product + ". " + alertcontents.imageHref
                        if (serverConfig.merch === "on")
                            PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                        alerttext = "<div class='text-secondary'>Merch: " + alertcontents.name + "  " + alertcontents.product + "</div>"
                        DisplayAlertMessages(alerttext);
                        break;
                    case "loyalty_store_redemption":
                        messagetxt += alertcontents.from + " for using the your channel points for " + alertcontents.product + ". " + alertcontents.imageHref
                        if (serverConfig.cloudbotredemption === "on")
                            PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                        alerttext = "<div class='text-secondary'>Loyalty: " + alertcontents.name + " " + alertcontents.product + "</div>"
                        DisplayAlertMessages(alerttext);
                        break;
                }
            }
            // ============================================================================
            //                           FUNCTION: PostMessageToDiscord
            // ============================================================================
            function PostMessageToDiscord (msg, channel)
            {
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket("ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "PostMessage",
                            serverConfig.extensionname,
                            {
                                message: msg,
                                channel: channel
                            },
                            "",
                            "discordchat"),
                        "",
                        "discordchat"
                    ));
            }
            // ============================================================================
            //                           FUNCTION: postMessageToTwitter
            // ============================================================================
            function postMessageToTwitter (msg1, msg2)
            {

                msg1 += " ";
                msg2 += " ";
                let msg_end = "Sent from StreamRoller";
                let msg_fact = "";

                if (serverConfig.randomfactstwitterstartenabled == "on" && localConfig.randomFact !== "")
                    msg_fact = "FOTD:" + localConfig.randomFact + " ";

                // we have enough space for everything 
                if (((msg1.length - 12) + msg2.length + msg_fact.length + msg_end.length) < 281)
                    msg1 = msg1 + msg2 + msg_fact + msg_end;
                //we have enough space if we remove the extra message
                else if (((msg1.length - 12) + msg_fact.length + msg_end.length) < 281)
                    msg1 = msg1 + msg_fact + msg_end;
                //we can't fit random fact and main message in so remove the random fact
                else if (((msg1.length - 12) + msg2.length + msg_end.length) < 281)
                    msg1 = msg1 + msg2 + msg_end;
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket("ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "PostTweet",
                            serverConfig.extensionname,
                            msg1,
                            "",
                            "twitter"),
                        "",
                        "twitter"
                    ));
            }
            // ============================================================================
            //                           FUNCTION: postMessageToTwitch
            // ============================================================================
            function postMessageToTwitch (msg, account = "bot")
            {
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket("ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "SendChatMessage",
                            serverConfig.extensionname,
                            // need to read accounts from twitchchat ext and give an option to chose who to send the message as
                            {
                                account: account,
                                message: msg,
                                'message-type': "chat"
                            },
                            "",
                            "twitchchat"),
                        "",
                        "twitchchat"
                    ));
            }
            // ============================================================================
            //                           FUNCTION: changeDiscordListeningChannel
            // ============================================================================
            function changeDiscordListeningChannel (channel)
            {
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket("ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "ChangeListeningChannel",
                            serverConfig.extensionname,
                            channel,
                            "",
                            "discordchat"),
                        "",
                        "discordchat"
                    ));
            }
            // ============================================================================
            //                           FUNCTION: chatInput
            // ============================================================================
            function chatInput (event)
            {
                event.preventDefault();
                postMessageToTwitch(document.getElementById("chatInputText").value, serverConfig.chatAsUsername)
                document.getElementById("chatInputText").value = ""
            }
            // ============================================================================
            //                           FUNCTION: modInput
            // ============================================================================
            function modInput (event)
            {
                event.preventDefault();
                PostMessageToDiscord(document.getElementById("modInputText").value, serverConfig.modmessage_channel);
                document.getElementById("modInputText").value = ""
            }
            // ============================================================================
            //                           FUNCTION: RequestRandomFact
            // ============================================================================
            function RequestRandomFact ()
            {
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket("ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "RequestRandomFact",
                            serverConfig.extensionname,
                            "",
                            "",
                            "randomfact"),
                        "",
                        "randomfact"
                    ));
            }
            // ============================================================================
            //                           FUNCTION: processRandomFact
            // ============================================================================
            function processRandomFact (data)
            {
                localConfig.randomFact = data;
            }
            // ============================================================================
            //                           FUNCTION: processTimers
            // ============================================================================
            function processTimers (data)
            {
                localConfig.timers[data.timername] = data.timerdata
            }

            // ============================================================================
            //                           FUNCTION: twitchFactOfTheDay
            // ============================================================================
            function twitchFactOfTheDay ()
            {
                if (localConfig.twitchRandomFactHandle != null)
                    clearTimeout(localConfig.twitchRandomFactHandle);

                localConfig.twitchRandomFactHandle = setTimeout(function ()
                {
                    postMessageToTwitch("Random Fact: " + localConfig.randomFact, "bot")
                    RequestRandomFact();
                    twitchFactOfTheDay();
                },
                    serverConfig.randomfactstimeout
                )
            }
            // ============================================================================
            //                           FUNCTION: addSongToStreamersonglistQueue
            // ============================================================================
            function addSongToStreamersonglistQueue (songId)
            {
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket("ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "AddSongToQueue",
                            serverConfig.extensionname,
                            songId,
                            "",
                            "streamersonglist"),
                        "",
                        "streamersonglist"
                    ));
            }
            // ============================================================================
            //                           FUNCTION: removeSongFromQueue
            // ============================================================================
            function removeSongFromQueue (queueId)
            {
                let classes = "bg-light text-dark"
                if (modeDark)
                    classes = "bg-dark text-light"
                $("#queue_" + queueId + "_remove").addClass("btn-warning").removeClass(classes)
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket("ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "RemoveSongFromQueue",
                            serverConfig.extensionname,
                            queueId,
                            "",
                            "streamersonglist"),
                        "",
                        "streamersonglist"
                    ));
            }
            // ============================================================================
            //                           FUNCTION: markSongAsPlayed
            // ============================================================================
            function markSongAsPlayed (queueId)
            {
                let classes = "bg-light text-dark"
                if (modeDark)
                    classes = "bg-dark text-light"
                $("#queue_" + queueId + "_played").addClass("btn-warning").removeClass(classes)
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket("ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "MarkSongAsPlayed",
                            serverConfig.extensionname,
                            queueId,
                            "",
                            "streamersonglist"),
                        "",
                        "streamersonglist"
                    ));
            }
            // ============================================================================
            //                           FUNCTION: updateSingerSonglistQueue
            // ============================================================================
            function updateSingerSonglistQueue (queue)
            {
                const tabletitle = document.getElementById("streamersonglisttitle")
                const queueTableBody = document.querySelector('#queueTableBody');
                queueTableBody.innerHTML = '';
                let tableentry = ""
                let song = ""
                let classes = "bg-light text-dark"
                if (modeDark == "true")
                    classes = "bg-dark text-light"

                // if we havent been passed an array just use the stored one (might just be a refresh)
                if (queue != [])
                    localConfig.setreamersonglist.queue = queue;

                tabletitle.innerHTML = "Song Queue (played today: " + localConfig.setreamersonglist.queue.status.songsPlayedToday
                    + ", in Queue: " + localConfig.setreamersonglist.queue.list.length + ")"
                localConfig.setreamersonglist.queue.list.forEach((entry) =>
                {
                    if (song != null)
                    {
                        song = entry.song
                        songtime = (new Date(entry.createdAt))
                        displaytime = songtime.getHours() + ":" + songtime.getMinutes().toString().padStart(2, '0')

                        tableentry += "<tr class = '" + classes + "'>"
                        tableentry += "<td>" + displaytime + "</td>";
                        tableentry += "<td>" + song.title + "</td>";
                        tableentry += "<td>" + song.artist + "</td>";
                        tableentry += "<td>" + (song.capo ? song.capo : "None") + "</td>";
                        // number of entries in the queue
                        tableentry += "<td>" + localConfig.setreamersonglist.queue.list.filter((v) => (v.songId === entry.songId)).length + "</td>";
                        tableentry += "<td>" + entry.requests[0].name + "</td>";
                        tableentry += "<td>" + entry.requests[0].inChat + "</td>";//inchat
                        tableentry += "<td " + (entry.donationAmount > 0 ? "style = 'background: rgb(208 0 255)'" : "") + ">" + entry.donationAmount + "</td>";//$

                        // mark as played button
                        tableentry += "<td><button id='queue_" + entry.id + "_played'class='btn " + classes + "' style='border:1px solid rgb(174, 255, 0)' onclick='markSongAsPlayed(" + entry.id + ")'>Played</button>";
                        // delete button
                        tableentry += "<button id='queue_" + entry.id + "_remove' class='btn " + classes + "' style='border:1px solid rgb(174, 50, 0)' onclick='removeSongFromQueue(" + entry.id + ")'>Remove</button>"
                        tableentry += "</td>";
                        tableentry += "</tr>"
                    }
                    else
                    {
                        //console.log("Empty list song")
                    }
                });

                queueTableBody.innerHTML = tableentry;
            }
            // ============================================================================
            //                           FUNCTION: updateSingerSonglistList
            // ============================================================================
            function updateSingerSonglistList (songlist)
            {
                localConfig.setreamersonglist.songlist = songlist;
            }
            // ============================================================================
            //                Songlist Autocomplete listener function
            // ============================================================================
            document.addEventListener("DOMContentLoaded", () => 
            {
                //add handler for when user types something
                $('#autocomplete-input').on('input', function ()
                {
                    var input = $(this).val().toLowerCase();
                    var autocompleteList = $('#autocomplete-list');
                    // how many items to show in list
                    var numbertodisplay = 5;
                    autocompleteList.empty();

                    if (input.length === 0)
                        return;

                    localConfig.setreamersonglist.songlist.some(function (item)
                    {
                        var itemLowerCase = item.title.toLowerCase();
                        if (itemLowerCase.indexOf(input) !== -1)
                        {
                            var listItem = $('<a id="songlistsearch" href="#songlistsearch" class="list-group-item list-group-item-action"></a>');
                            listItem.text(item.title);
                            listItem.on('click', function ()
                            {
                                $('#autocomplete-input').val("");
                                addSongToStreamersonglistQueue(item.id)
                                autocompleteList.empty();
                            });

                            autocompleteList.append(listItem);
                            numbertodisplay--;
                            if (numbertodisplay < 1)
                                return true

                        }
                    });
                });
            });
            // ============================================================================
            //                           FUNCTION: heartBeat
            // ============================================================================
            heartBeatCallback()
            function heartBeatCallback ()
            {
                if (DataCenterSocket.connected)
                {
                    document.getElementById('shutdownbutton').classList.add("btn-success");
                    document.getElementById('shutdownbutton').classList.remove("btn-danger");
                    document.getElementById('shutdownbutton').style.color = "green";
                    document.getElementById('shutdownbuttonsvg').style.fill = "green"
                }
                else
                {
                    document.getElementById('shutdownbutton').classList.add("btn-danger");
                    document.getElementById('shutdownbutton').classList.remove("btn-success");
                    document.getElementById('shutdownbutton').style.color = "red"
                    document.getElementById('shutdownbuttonsvg').style.fill = "red"
                }
                localConfig.heartBeatHandle = setTimeout(heartBeatCallback, localConfig.heartBeatTimeout)
            }
            // ============================================================================
            //                           FUNCTION: Power Button
            // ============================================================================
            const powerbutton = document.getElementById('shutdownbutton_menu')
            powerbutton.addEventListener('click', function (e)
            {
                e.preventDefault(); // cancel the link behaviour
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket(e.target.text,
                        serverConfig.extensionname,
                        e.target.text,
                        "",
                        ""
                    ));
            });

            // ============================================================================
            //                           FUNCTION: Power Button
            // ============================================================================
            function setCardsVisibility ()
            {
                let card = document.getElementById("StreamerSongListCard");
                (serverConfig.streamersonglistdisplay == "on") ? (card.style.display = "block") : (card.style.display = "none");

                card = document.getElementById("ModMessagesCard");
                (serverConfig.discordmodchatdisplay == "on") ? (card.style.display = "block") : (card.style.display = "none");
            }
        </script>